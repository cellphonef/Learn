# 数据结构与算法

数据结构与算法即"数据结构"+"算法"。

"数据结构"是组织数据的方式，而"算法"是在具体数据结构上执行的特定操作。



## 数据结构

数据结构，顾名思义就是数据的结构。



### 数组





### 单链表





### 栈



### 队列



### 字符串





### 树





### 图





## 算法



### 排序





**冒泡排序**

> 算法思想



> 代码：从前到后遍历

```c
void bubbleSort(int* arr, int size)
{
    for (int i = 0; i < size - 1; ++i)
    {
        for (int j = 0; j < size - i - 1; ++j)
        {
            if (arr[j] > arr[j + 1])
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

算法分析：

- 时间复杂度为O(N^2)。
- 原地排序，不需要额外空间。
- 稳定。



优化





**简单选择排序**

> 算法思想

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

初始状态：未排序序列为整个序列，排序序列为空。

> 代码

```c
void selectSort(int arr[], int size)
{
    for (int i = 0; i < size - 1; ++i)
    {
        int minIdx = i;  
        for (int j = i + 1; j < size; ++j)
        {
            if (arr[minIdx] > arr[j])
            {
                minIdx = j;
            }
        }
        if (i != minIdx) 
        {	
            int temp = arr[i];
            arr[i] = arr[minIdx];
            arr[minIdx] = temp;
            
        }     
    }
    
}

```







**直接插入排序**

> 算法思想





> 代码

```C
void insertSort(int arr[], int size)
{
  for (int i = 1; i < size; ++i)
  {
      int currValue = arr[i];
      int j = i;  // j为要插入的位置，初始化为当前位置。
      
      while (arr[j - 1] > currValue && j > 0)  // 对插入位置j进行调整
      {
          arr[j] = arr[j - 1];
          j--;
      }
      
      arr[j] = currValue;  // 将数据插入到j位置。
  }
}
```





**归并排序**





**快速排序**







### 查找





## 四大算法策略

四大算法策略包括：

- 贪心算法。
- 分治算法。
- 回溯算法。
- 动态规划。

它们是解决问题的不同策略，有的策略有固定的模板，有的没有。



### 贪心算法

贪心算法，通过局部最优解来得到最终最优解。









### 分治算法







### 回溯算法

> 定义

回溯算法实际上是一种类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就"回溯"返回，尝试别的路径。回溯算法是一种选优搜索法，按选优条件向前搜索，已达到目标。当在探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的算法思想就是回溯算法。



> 算法模板

回溯算法通常使用递归实现（与树有关的算法一般都可以用递归实现）。

:bulb:：递归，分为递和归。



首先我们知道遍历一颗真正的多叉树方法如下：

```c
void traverse(TreeNode* root)
{
    if (root为空)
        return;
    
    for (TreeNode* child: children)
   		traverse(child);
}
```



```c
void backtrace(返回结果列表res, 选择列表selectList, 路径列表track)
{
    if 满足结束条件:
    	res.add(track)
    	return
        
    for 选择 in selectList:
        做选择，即将选择加入track
        backtrace(res, selectList, track)
        撤销选择，即将选择弹出track
    
}
```



`backtrace`函数其实就像一个指针，在这颗树上游走，同时要正确维护每个节点的属性。



















