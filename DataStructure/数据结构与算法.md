# 数据结构与算法

数据结构与算法即"数据结构"+"算法"。

"数据结构"是组织数据的方式，而"算法"是在具体数据结构上执行的特定操作。



## 数据结构

数据结构，顾名思义就是数据的结构。

在计算机中，数据都存放在内存中，因此数据在计算机中的存储结构只有两种：数组和链表，分别对应内存中的连续存储和离散存储。

### 数组

数组，就是一段连续内存空间，这一段连续内存空间被分割成一个一个的小空间存放数据。

```c
/* 栈上分配，自动回收 */
ElemType data[MAX_SIZE];

/* 堆上分配，手动回收 */
ElemType* data = (ElemType*)malloc(sizeof(ElemType)*MAX_SIZE);
free(data); 
```





### 单链表

链表，就是一系列离散内存空间，每个离散内存空间称为一个结点，结点内存放数据和指针，其中指针用于连接其他离散内存空间。

```C
/* 结点 */
typedef struct Node {
    ElemType value;    /* 数据域 */
    struct Node* next; /* 指针域 */
}Node;

/* 单链表，使用指向链表头部的指针即可表示 */
typedef Node* SingleLinkList;

/* 初始化单链表，带头结点 */
Status InitSingleLinkList(SingleLinkList* s)
{
    *s = (SingleLinkList)malloc(sizeof(Node));
    if (!(*s))
        return ERROR;
    (*s)->next = NULL;
    return OK;
}

/* 按位序插入，带头结点 */
Status ListInsert(SingleLinkList* s, int pos, ElemType e)
{
    SingleLinkList p, q;
    p = *s;
    int i = 1;
    while (p && i < pos) {  /* 寻找第pos个结点 */
        p = p->next;
        i++;
    }
    
    if (!p || i > pos)  /* while循环结束的两种情况：1.pos超出范围，2.pos为非正数 */
        return ERROR;
    q = (SingleLinkList)malloc(sizeof(Node));
    q->value = e;
    q->next = p->next;
    p->next = q;
    return OK;
}


/* 按位序删除，带头结点 */
Status ListDelete(SingleLinkList* s, int pos, ElemType* e)
{
    SingleLinkList p, q;
    p = *s;
    int i = 1;
    while (p && i < pos) {
        p = p->next;
        i++;
    }
    
    if (!p || i > pos)
        return ERROR;
    q = p->next;
    *e = q->value;
    p->next = q->next;
    free(q);
    return OK;
    
}

/* 遍历单链表，带头结点 */
Status ListTraverse(SingleLinkList s)
{
    SingleLinkList p = s->next;
    while (p) {
        printf("%d ", p->value);
        p = p->next;
    }
    printf("\n");
    return OK;
}

/* 单链表判空，带头结点 */
Status ListEmpty(SingleLinkList s)
{
    return s->next ? FALSE : TRUE;
}

/* 清空单链表，带头结点 */
Status ClearList(SingleLinkList* s)
{
    SingleLinkList p, q;
    p = (*s)->next;
    while (p) {
        q = p->next;
        free(p);
        p = q;
    }
    (*s)->next = NULL;
    return OK;
    
}

/* 如果是不带头结点的单链表，则某些操作上有以下区别：
** - 对于插入操作，第一个位置的插入与其他位置插入不同，因为第一个位置没有前驱结点。
** - 对于删除操作，第一个位置的删除与其他位置删除不同，因为第一个位置没有前驱结点。
** 因此，使用头结点可以使得这些操作的统一，因为头结点可以充当第一个位置的前驱结点。
*/ 
```

完整代码见：[SingleLinkList.c]()



**存储结构只有两种，但数据结构种类多种多样，究其原因本质上只是对存储结构进行封装，提供不同的接口而已。这些不同的数据结构底层存储结构也无非就是以上两种，只是操作的方式特性不同，为此我们可以将这些不同的数据结构看成是逻辑结构。这些逻辑结构包括以下：**

- **栈**
- **队列**
- **树**
- **图**
- **散列表**
- **...**



### 栈

栈的特性是后进先出（LIFO）。



**顺序栈**

顺序栈，即底层存储结构使用数组实现。

C语言实现静态顺序栈：

```c
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 64     /* 栈容量 */
typedef int Status;

typedef int ElemType;  /* ElemType类型根据实际情况而定，这里假设为int */
typedef struct {
    ElemType data[MAXSIZE];
    int top;           /* 栈顶指针 */
}SqStack;

void InitStack(SqStack* s) 
{
    s->top = -1;
}

Status Push(SqStack* s, ElemType e)
{
    if (s->top == MAXSIZE - 1)  /* 栈满 */
       return ERROR;
    s->data[++top] = e;
    return OK;
}

Status Pop(SqStack* s, ElemType* e)
{
    if (s->top == -1)  /* 栈空 */
        return ERROR;
    *e = s->data[top--];
    return OK;
}

ElemType GetTop(SqStack* s)
{
    if (s->top == -1)  /* 栈空 */
        return ERROR;
    return s->data[top];
}

int StackLength(SqStack* s)
{
    return s->top == -1 ? 0 : top + 1;
}

int StackEmpty(SqStack* s)
{
    return s->top == -1;
}

void ClearStack(SqStack* s)
{
    s->top == -1;
}

void DestoryStack(SqStack* s)
{
    ClearStack(s);
    s->data = NULL;
}
```

完整代码间：[SqStack.c]()





**链式栈**

链式栈，即底层存储结构使用链表实现。



C语言实现链式栈：

```C
/* 结点 */
typedef int ElemType;
typedef struct Node {
    ElemType value;
    struct Node* next;   
}Node, *LinkStackPtr;

/* 链式栈 */
typedef struct LinkStack {
    LinkStackPtr top;  /* 栈顶 */
    int count;         /* 栈的元素个数 */
}LinkStack;

/* 栈初始化 
** 对于链式栈，其实就是特殊的单链表（只在头部插入和删除）
*/
void InitStack(LinkStack* s)
{
    s->top = NULL;
    count = 0;
}


Status Push(LinkStack* s, ElemType e)
{
    LinkStackPtr newNode = (LinkStackPtr)malloc(sizeof(Node));
    newNode->value = e;
    newNode->next = NULL;
    newNode->next = s->top;
    s->top = newNode;
    return OK;
}

Status Pop(LinkStack* s, ElemType* e)
{
   Node* p; 
   if (s->top == NULL)
       return ERROR;
    p = s->top;
    *e = p->value;
    
    s->top = s->top->next;
    s->count--;
    free(p);
    return OK;
    
}



```

完整代码见：[LinkStack.c]()





**栈的作用**











### 队列

队列的特性是先进先出（FIFO）。



**顺序队列**



完整代码见：



**链式队列**



完整代码见：



**队列的作用**





### 字符串





### 树





### 图





## 算法




### 排序





**冒泡排序**

> 算法思想



> 代码：从前到后遍历

```c
void bubbleSort(int arr[], int size)
{
    /* 
    ** 外层循环作用：控制轮次。 
    ** i可以看成对应目前有序区间中的有序元素个数，初始为0。
    */
    for (int i = 0; i < size - 1; ++i) {
        /* 
        ** 内层循环作用：从未排序区间中搜索出元素存放到有序区间。
        ** 搜索的未排序区间的终点与轮次i有关，因为每一轮在未排序区间的末尾都存放正确的值。 
        */
        for (int j = 0; j < size - i - 1; ++j) {  
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

算法分析：

- 时间复杂度为O(N^2)。
- 原地排序，不需要额外空间。
- 稳定。



优化





**简单选择排序**

> 算法思想

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

初始状态：未排序序列为整个序列，排序序列为空。

> 代码

```c
void selectSort(int arr[], int size)
{
    /*
    ** 外层循环作用：控制轮次。
    ** i可以看成对应目前有序区间中的有序元素个数，初始为0。
    */
    for (int i = 0; i < size - 1; ++i)
    {
        /*
        ** 内层循环作用：从未排序区间中搜索出合适的元素交换到有序区间。
        ** 搜索的未排序区间的起点与i有关（默认存放在该未排序区间开头的是当前位置的元素），
        ** 因此，每次搜索从i+1开始。
        */
        int minIdx = i;
        for (int j = i + 1; j < size; ++j)
        {
            if (arr[minIdx] > arr[j])
            {
                minIdx = j;
            }
        }
        if (i != minIdx) 
        {	
            int temp = arr[i];
            arr[i] = arr[minIdx];
            arr[minIdx] = temp;
            
        }     
    }
    
}

```







**直接插入排序**

> 算法思想





> 代码

```C
void insertSort(int arr[], int size)
{
  for (int i = 1; i < size; ++i)
  {
      int currValue = arr[i];
      int j = i;  // j为要插入的位置，初始化为当前位置。
      
      while (arr[j - 1] > currValue && j > 0)  // 对插入位置j进行调整
      {
          arr[j] = arr[j - 1];
          j--;
      }
      
      arr[j] = currValue;  // 将数据插入到j位置。
  }
}
```





**归并排序**

迭代实现：











递归实现：

```c
/* 主函数 */
void mSort(int arr[], int size)
{
    int* tempArr = (int*)malloc(size * sizeof(int));
    mergeSort(arr, tempArr, 0, size - 1);
    free(tempArr);
}

/* 归并排序, 递归函数 */
void mergeSort(int arr[], int tempArr[], int start, int end)
{
    if (start >= end)  /* >号我认为是防止用户传入非法start和end */
        return;
    int mid = (start + end) / 2;    /* start + end可能溢出 */
    /* 防止溢出：
    ** 做法：int mid = start + (end - start) / 2;
    ** 理由：start, end - start, (end - start) / 2均小于或等于end因此都不会溢出。
    **      并且start + (end - start) / 2 也小于或等于end因此也不会溢出。
    ** 优化：int mid = start + ((end - start) >> 1);
    ** 推广：所有求中间值都可以使用这种方法来防止溢出。
    */ 
    mergeSort(arr, tempArr, start, mid);
    mergeSort(arr, tempArr, mid + 1, end);
    merge(arr, tempArr, start, mid, end);
}


/* 合并  */
void merge(int arr[], int tempArr[], int start, int mid, int end)
{
    int i = start;
    int j = mid + 1;
    int k = start;
    while (i <= mid && j <= end) {
        if (arr[i] <= arr[j]) {
            tempArr[k++] = arr[i++];
        else 
            tempArr[k++] = arr[j++]; 
    }

    while (i <= mid)
        tempArr[k++] = arr[i++];

    while (j <= end) 
        tempArr[k++] = arr[j++];


    for (int i = start; i <= end; i++)
        arr[i] = tempArr[i];

}
```

完整代码见：[mergeSort.c]()





**快速排序**

> 时间复杂度O(NlogN)是仅基于比较的排序算法中的最快时间复杂度。

```c
/* 主函数 */
void qSort(int arr[], int size)
{
    quickSort(arr, 0, size - 1);
}

void quickSort(int arr[], int start, int end)
{
    if (start >= end)
        return;
    int pivot = partition(arr, start, end);
    quickSort(arr, start, pivot - 1);
    quickSort(arr, pivot +1, end);
}


/* 挖坑法 */
void partition_one(int arr[], int start, int end)
{
    int value = arr[start];
    while (start < end) {
        while (value <= arr[end] && start < end)
            end--;
        
        if (start < end) {
            arr[start] = arr[end];
        }
        
        while(value > arr[start] && start < end)
            start++;
        
        if (start < end) 
            arr[end] = arr[start];
    }
    arr[start] = value;
    return start;
}

void partition_two(int arr[], int start, int end)
{
    
}




```











**堆排序**





**计数排序**



**桶排序**









### 查找



**顺序查找**



**二分查找**













## 四大算法策略

四大算法策略包括：

- 贪心算法。
- 分治算法。
- 回溯算法。
- 动态规划。

它们是解决问题的不同策略，有的策略有固定的模板，有的没有。

其中回溯算法、动态规划、贪心算法本质上来说就是「穷举」：
- 回溯算法穷举**所有可能的解（存在冗余）**，然后找到可行解或最优解。
- 动态规划**无冗余的穷举所有的解**，然后得到最优解。
- 贪心算法**根据贪心选择性质穷举**，然后得到最优解。

对于动态规划，我们不关心最优解是怎么得到的，即不清楚过程，因此适用于只需要知道最优值而不需要知道过程的问题。而对于贪心算法和回溯算法，我们可以关心也可以不关心最优解是怎么得到的，即可以得出过程。最后，对于回溯算法，由于其穷举所有解，因此可以解决所有问题。







### 分治算法

分治法就是将原问题分解成若干子问题，然后通过解决子问题，最后合并子问题来得到原问题的解。





### 回溯算法

> 定义

回溯算法实际上是一种类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就"回溯"返回，尝试别的路径。回溯算法是一种选优搜索法，按选优条件向前搜索，已达到目标。当在探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的算法思想就是回溯算法。



> 算法模板

回溯算法通常使用递归实现（与树有关的算法一般都可以用递归实现）。

:bulb:：递归，分为递和归。



首先我们知道遍历一颗真正的多叉树方法如下：

```c
void traverse(TreeNode* root)
{
    if (root为空)
        return;
    
    for (TreeNode* child: children)
   		traverse(child);
}
```



```c
void backtrace(返回结果列表res, 选择列表selectList, 路径列表track)
{
    if 满足结束条件:
    	res.add(track)
    	return
        
    for 选择 in selectList:
        做选择，即将选择加入track
        backtrace(res, selectList, track)
        撤销选择，即将选择弹出track
    
}
```



`backtrace`函数其实就像一个指针，在这颗树上游走，同时要正确维护每个节点的属性。



### 动态规划与贪心算法

「动态规划」也是一种分治思想（比如其状态转移方程就是一种分治），但与分治算法不同的是，分治算法是把原问题分解成若干子问题，然后自顶向下求解子问题，合并子问题的解，从而得到原问题的解。动态规划也是吧原问题分割为若干子问题，然后自底向上，先求解最小的子问题，把结果保存在表格中，在求解大的子问题时，直接从表格中查询小的子问题的解，避免重复计算。

**动态规划适用情况**

能够使用动态规划求解的问题一般要具有2个性质：
- **最优子结构**：即问题的最优解包含其子问题的最优解。（该性质是动态规划适用的必要条件）
- **重叠子问题**：即子问题之间是不独立的，一个子问题的结果可能会被多次用到，因此会被多次计算，动态规划就是为了消除其重叠子问题而设计的。（该性质并不是动态规划适用的必要条件，而是如果没有这条性质，动态规划算法同其他算法相比就不具备优势。）



「贪心算法」，通过局部最优解来得到最终最优解。

**贪心算法适用情况**





能够适用贪心算法求解的问题一般具有2个性质：
- **贪心选择性质**：
- **最优子结构**：

**贪心算法的设计**

贪心算法的设计一般是先排序后根据贪心选择策略依次选择，直到不能再选择时将得到最优解。


**证明贪心算法正确性**

贪心算法最难得部分就是正确性的证明，常用的方法有归纳法（对算法步数进行归纳和对问题规模进行归纳）和交换论证法（从最优解出发，不变坏地替换，得到贪心策略的解）

对算法步数进行归纳

存在最优解O包含


参考：
1. [贪心算法的正确性证明](https://blog.csdn.net/pkueecscss/article/details/88578060)
2. [从活动选择问题看动态规划和贪心算法的区别与联系](https://www.cnblogs.com/hapjin/p/5573419.html)


