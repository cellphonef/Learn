# 数据结构与算法

数据结构与算法即"数据结构"+"算法"。

"数据结构"是组织数据的方式，而"算法"是在具体数据结构上执行的特定操作。



## 数据结构

数据结构，顾名思义就是数据的结构。

在计算机中，数据都存放在内存中，因此数据在计算机中的存储结构只有两种：数组和链表，分别对应内存中的连续存储和离散存储。

### 数组

数组，就是一段连续内存空间，这一段连续内存空间被分割成一个一个的小空间存放数据。

```c
/* 栈上分配，自动回收 */
ElemType data[MAX_SIZE];

/* 堆上分配，手动回收 */
ElemType* data = (ElemType*)malloc(sizeof(ElemType)*MAX_SIZE);
free(data); 
```





### 单链表

链表，就是一系列离散内存空间，每个离散内存空间称为一个结点，结点内存放数据和指针，其中指针用于连接其他离散内存空间。

```C
/* 结点 */
typedef struct Node {
    ElemType value;
    struct Node* next;
}Node;

/* 单链表，使用指向链表头部的指针即可表示 */
typedef Node* SingleLinkList;

/* 初始化单链表，带头结点 */
Status InitSingleLinkList(SingleLinkList* s)
{
    *s = (SingleLinkList)malloc(sizeof(Node));
    if (!(*s))
        return ERROR;
    (*s)->next = NULL;
    return OK;
}

/* 按位序插入，带头结点 */
Status ListInsert(SingleLinkList* s, int pos, ElemType e)
{
    SingleLinkList p, q;
    p = *s;
    int i = 1;
    while (p && i < pos) {  /* 寻找第pos个结点 */
        p = p->next;
        i++;
    }
    
    if (!p || i > pos)  /* while循环结束的两种情况：1.pos超出范围，2.pos为非正数 */
        return ERROR;
    q = (SingleLinkList)malloc(sizeof(Node));
    q->value = e;
    q->next = p->next;
    p->next = q;
    return OK;
}


/* 按位序删除，带头结点 */
Status ListDelete(SingleLinkList* s, int pos, ElemType* e)
{
    SingleLinkList p, q;
    p = *s;
    int i = 1;
    while (p && i < pos) {
        p = p->next;
        i++;
    }
    
    if (!p || i > pos)
        return ERROR;
    q = p->next;
    *e = q->value;
    p->next = q->next;
    free(q);
    return OK;
    
}

/* 遍历单链表，带头结点 */
Status ListTraverse(SingleLinkList s)
{
    SingleLinkList p = s->next;
    while (p) {
        printf("%d ", p->value);
        p = p->next;
    }
    printf("\n");
    return OK;
}

/* 单链表判空，带头结点 */
Status ListEmpty(SingleLinkList s)
{
    return s->next ? FALSE : TRUE;
}

/* 清空单链表，带头结点 */
Status ClearList(SingleLinkList* s)
{
    SingleLinkList p, q;
    p = (*s)->next;
    while (p) {
        q = p->next;
        free(p);
        p = q;
    }
    (*s)->next = NULL;
    return OK;
    
}

/* 如果是不带头结点的单链表，则某些操作上有以下区别：
** - 对于插入操作，第一个位置的插入与其他位置插入不同，因为第一个位置没有前驱结点。
** - 对于删除操作，第一个位置的删除与其他位置删除不同，因为第一个位置没有前驱结点。
** 因此，使用头结点可以使得这些操作的统一，因为头结点可以充当第一个位置的前驱结点。
*/ 
```

完整代码见：[SingleLinkList.c]()



**存储结构只有两种，但数据结构种类多种多样，究其原因本质上只是对存储结构进行封装，提供不同的接口而已。这些不同的数据结构底层存储结构也无非就是以上两种，只是操作的方式特性不同，为此我们可以将这些不同的数据结构看成是逻辑结构。这些逻辑结构包括以下：**

- **栈**
- **队列**
- **树**
- **图**
- **散列表**
- **...**



### 栈

栈的特性是后进先出（LIFO）。



**顺序栈**

顺序栈，即底层存储结构使用数组实现。

C语言实现静态顺序栈：

```c
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 64     /* 栈容量 */
typedef int Status;

typedef int ElemType;  /* ElemType类型根据实际情况而定，这里假设为int */
typedef struct {
    ElemType data[MAXSIZE];
    int top;           /* 栈顶指针 */
}SqStack;

void InitStack(SqStack* s) 
{
    s->top = -1;
}

Status Push(SqStack* s, ElemType e)
{
    if (s->top == MAXSIZE - 1)  /* 栈满 */
       return ERROR;
    s->data[++top] = e;
    return OK;
}

Status Pop(SqStack* s, ElemType* e)
{
    if (s->top == -1)  /* 栈空 */
        return ERROR;
    *e = s->data[top--];
    return OK;
}

ElemType GetTop(SqStack* s)
{
    if (s->top == -1)  /* 栈空 */
        return ERROR;
    return s->data[top];
}

int StackLength(SqStack* s)
{
    return s->top == -1 ? 0 : top + 1;
}

int StackEmpty(SqStack* s)
{
    return s->top == -1;
}

void ClearStack(SqStack* s)
{
    s->top == -1;
}

void DestoryStack(SqStack* s)
{
    ClearStack(s);
    s->data = NULL;
}
```

完整代码间：[SqStack.c]()





**链式栈**

链式栈，即底层存储结构使用链表实现。



C语言实现链式栈：

```C
/* 结点 */
typedef int ElemType;
typedef struct Node {
    ElemType value;
    struct Node* next;   
}Node, *LinkStackPtr;

/* 链式栈 */
typedef struct LinkStack {
    LinkStackPtr top;  /* 栈顶 */
    int count;         /* 栈的元素个数 */
}LinkStack;

/* 栈初始化 
** 对于链式栈，其实就是特殊的单链表（只在头部插入和删除）
*/
void InitStack(LinkStack* s)
{
    s->top = NULL;
    count = 0;
}


Status Push(LinkStack* s, ElemType e)
{
    LinkStackPtr newNode = (LinkStackPtr)malloc(sizeof(Node));
    newNode->value = e;
    newNode->next = NULL;
    newNode->next = s->top;
    s->top = newNode;
    return OK;
}

Status Pop(LinkStack* s, ElemType* e)
{
   Node* p; 
   if (s->top == NULL)
       return ERROR;
    p = s->top;
    *e = p->value;
    
    s->top = s->top->next;
    s->count--;
    free(p);
    return OK;
    
}



```

完整代码见：[LinkStack.c]()













### 队列

队列的特性是先进先出（FIFO）。



**顺序队列**



完整代码见：



**链式队列**



完整代码见：









### 字符串





### 树





### 图





## 算法



### 排序





**冒泡排序**

> 算法思想



> 代码：从前到后遍历

```c
void bubbleSort(int arr[], int size)
{
    /* 
    ** 外层循环作用：控制轮次。 
    ** i可以看成对应目前有序区间中的有序元素个数，初始为0。
    */
    for (int i = 0; i < size - 1; ++i) {
        /* 
        ** 内层循环作用：从未排序区间中搜索出元素存放到有序区间。
        ** 搜索的未排序区间的终点与轮次i有关，因为每一轮在未排序区间的末尾都存放正确的值。 
        */
        for (int j = 0; j < size - i - 1; ++j) {  
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

算法分析：

- 时间复杂度为O(N^2)。
- 原地排序，不需要额外空间。
- 稳定。



优化





**简单选择排序**

> 算法思想

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

初始状态：未排序序列为整个序列，排序序列为空。

> 代码

```c
void selectSort(int arr[], int size)
{
    /*
    ** 外层循环作用：控制轮次。
    ** i可以看成对应目前有序区间中的有序元素个数，初始为0。
    */
    for (int i = 0; i < size - 1; ++i)
    {
        /*
        ** 内层循环作用：从未排序区间中搜索出合适的元素交换到有序区间。
        ** 搜索的未排序区间的起点与i有关（默认存放在该未排序区间开头的是当前位置的元素），
        ** 因此，每次搜索从i+1开始。
        */
        int minIdx = i;
        for (int j = i + 1; j < size; ++j)
        {
            if (arr[minIdx] > arr[j])
            {
                minIdx = j;
            }
        }
        if (i != minIdx) 
        {	
            int temp = arr[i];
            arr[i] = arr[minIdx];
            arr[minIdx] = temp;
            
        }     
    }
    
}

```







**直接插入排序**

> 算法思想





> 代码

```C
void insertSort(int arr[], int size)
{
  for (int i = 1; i < size; ++i)
  {
      int currValue = arr[i];
      int j = i;  // j为要插入的位置，初始化为当前位置。
      
      while (arr[j - 1] > currValue && j > 0)  // 对插入位置j进行调整
      {
          arr[j] = arr[j - 1];
          j--;
      }
      
      arr[j] = currValue;  // 将数据插入到j位置。
  }
}
```





**归并排序**

迭代实现：











递归实现：

```c
/* 主函数 */
void mSort(int arr[], int size)
{
    int* tempArr = (int*)malloc(size * sizeof(int));
    mergeSort(arr, tempArr, 0, size - 1);
    free(tempArr);
}

/* 归并排序, 递归函数 */
void mergeSort(int arr[], int tempArr[], int start, int end)
{
    if (start >= end)  /* >号我认为是防止用户传入非法start和end */
        return;
    int mid = (start + end) / 2;    /* start + end可能溢出 */
    /* 防止溢出：
    ** 做法：int mid = start + (end - start) / 2;
    ** 理由：start, end - start, (end - start) / 2均小于end因此都不会溢出。
    **      并且start + (end - start) / 2 也小于end因此也不会溢出。
    ** 优化：int mid = start + ((end - start) >> 1);
    ** 推广：所有求中间值都可以使用这种方法来防止溢出。
    */ 
    mergeSort(arr, tempArr, start, mid);
    mergeSort(arr, tempArr, mid + 1, end);
    merge(arr, tempArr, start, mid, end);
}


/* 合并  */
void merge(int arr[], int tempArr[], int start, int mid, int end)
{
    int i = start;
    int j = mid + 1;
    int k = start;
    while (i <= mid && j <= end) {
        if (arr[i] <= arr[j]) {
            tempArr[k++] = arr[i++];
        else 
            tempArr[k++] = arr[j++]; 
    }

    while (i <= mid)
        tempArr[k++] = arr[i++];

    while (j <= end) 
        tempArr[k++] = arr[j++];


    for (int i = start; i <= end; i++)
        arr[i] = tempArr[i];

}
```

完整代码见：[mergeSort.c]()





**快速排序**



**堆排序**





**计数排序**



**桶排序**









### 查找



**顺序查找**



**二分查找**













## 四大算法策略

四大算法策略包括：

- 贪心算法。
- 分治算法。
- 回溯算法。
- 动态规划。

它们是解决问题的不同策略，有的策略有固定的模板，有的没有。



### 贪心算法

贪心算法，通过局部最优解来得到最终最优解。









### 分治算法







### 回溯算法

> 定义

回溯算法实际上是一种类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就"回溯"返回，尝试别的路径。回溯算法是一种选优搜索法，按选优条件向前搜索，已达到目标。当在探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的算法思想就是回溯算法。



> 算法模板

回溯算法通常使用递归实现（与树有关的算法一般都可以用递归实现）。

:bulb:：递归，分为递和归。



首先我们知道遍历一颗真正的多叉树方法如下：

```c
void traverse(TreeNode* root)
{
    if (root为空)
        return;
    
    for (TreeNode* child: children)
   		traverse(child);
}
```



```c
void backtrace(返回结果列表res, 选择列表selectList, 路径列表track)
{
    if 满足结束条件:
    	res.add(track)
    	return
        
    for 选择 in selectList:
        做选择，即将选择加入track
        backtrace(res, selectList, track)
        撤销选择，即将选择弹出track
    
}
```



`backtrace`函数其实就像一个指针，在这颗树上游走，同时要正确维护每个节点的属性。