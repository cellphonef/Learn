# 数据结构与算法

数据结构与算法即"数据结构"+"算法"。

"数据结构"是组织数据的方式，而"算法"是在具体数据结构上执行的特定操作。



## 数据结构

数据结构，顾名思义就是数据的结构。

在计算机中，数据都存放在内存中，因此数据在计算机中的存储结构只有两种：数组和链表，分别对应内存中的连续存储和离散存储。

### 数组

数组，就是一段连续内存空间，这一段连续内存空间被分割成一个一个的小空间存放数据。





### 单链表

链表，就是一系列离散内存空间，每个离散内存空间称为一个结点，结点内存放数据和指针，其中指针用于连接其他离散内存空间。

```C
// 结点
struct Node {
    ElemType value;
    Node* next;
}
```







存储结构只有两种，但数据结构种类多种多样，





### 栈

栈的特性是后进先出（LIFO）。



**顺序栈**

顺序栈，即底层存储结构使用数组实现。

C语言实现静态顺序栈：

```c
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 64     /* 栈容量 */
typedef int Status;

typedef int ElemType;  /* ElemType类型根据实际情况而定，这里假设为int */
typedef struct {
    ElemType data[MAXSIZE];
    int top;           /* 栈顶指针 */
}SqStack;

void InitStack(SqStack* s) 
{
    s->top = -1;
}

Status Push(SqStack* s, ElemType e)
{
    if (s->top == MAXSIZE - 1)  /* 栈满 */
       return ERROR;
    s->data[++top] = e;
    return OK;
}

Status Pop(SqStack* s, ElemType* e)
{
    if (s->top == -1)  /* 栈空 */
        return ERROR;
    *e = s->data[top--];
    return OK;
}

ElemType GetTop(SqStack* s)
{
    if (s->top == -1)  /* 栈空 */
        return ERROR;
    return s->data[top];
}

int StackLength(SqStack* s)
{
    return s->top == -1 ? 0 : top + 1;
}

int StackEmpty(SqStack* s)
{
    return s->top == -1;
}

void ClearStack(SqStack* s)
{
    s->top == -1;
}

void DestoryStack(SqStack* s)
{
    ClearStack(s);
    s->data = NULL;
}
```



**链式栈**

链式栈，即底层存储结构使用链表实现。



C语言实现链式栈：

```C


typedef int ElemType;
typedef struct Node {
    ElemType value;
    struct Node* next;   
}Node, *LinkStackPtr;

typedef struct LinkStack {
    LinkStackPtr top;  /* 栈顶 */
    int count;
}LinkStack;

void InitStack(LinkStack* s)
{
    s->top->next = NULL;
    count = 0;
}


Status Push(LinkStack* s, ElemType e)
{
    LinkStackPtr newNode = (LinkStackPtr)malloc(sizeof(Node));
    newNode->value = e;
    newNode->next = s->top->next;
    s->top->next = newNode;
    
}

```











### 队列

队列的特性是先进先出（FIFO）。







### 字符串





### 树





### 图





## 算法



### 排序





**冒泡排序**

> 算法思想



> 代码：从前到后遍历

```c
void bubbleSort(int* arr, int size)
{
    for (int i = 0; i < size - 1; ++i)
    {
        for (int j = 0; j < size - i - 1; ++j)
        {
            if (arr[j] > arr[j + 1])
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

算法分析：

- 时间复杂度为O(N^2)。
- 原地排序，不需要额外空间。
- 稳定。



优化





**简单选择排序**

> 算法思想

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

初始状态：未排序序列为整个序列，排序序列为空。

> 代码

```c
void selectSort(int arr[], int size)
{
    for (int i = 0; i < size - 1; ++i)
    {
        int minIdx = i;  
        for (int j = i + 1; j < size; ++j)
        {
            if (arr[minIdx] > arr[j])
            {
                minIdx = j;
            }
        }
        if (i != minIdx) 
        {	
            int temp = arr[i];
            arr[i] = arr[minIdx];
            arr[minIdx] = temp;
            
        }     
    }
    
}

```







**直接插入排序**

> 算法思想





> 代码

```C
void insertSort(int arr[], int size)
{
  for (int i = 1; i < size; ++i)
  {
      int currValue = arr[i];
      int j = i;  // j为要插入的位置，初始化为当前位置。
      
      while (arr[j - 1] > currValue && j > 0)  // 对插入位置j进行调整
      {
          arr[j] = arr[j - 1];
          j--;
      }
      
      arr[j] = currValue;  // 将数据插入到j位置。
  }
}
```





**归并排序**





**快速排序**



**堆排序**





**计数排序**



**桶排序**









### 查找



**顺序查找**



**二分查找**













## 四大算法策略

四大算法策略包括：

- 贪心算法。
- 分治算法。
- 回溯算法。
- 动态规划。

它们是解决问题的不同策略，有的策略有固定的模板，有的没有。



### 贪心算法

贪心算法，通过局部最优解来得到最终最优解。









### 分治算法







### 回溯算法

> 定义

回溯算法实际上是一种类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就"回溯"返回，尝试别的路径。回溯算法是一种选优搜索法，按选优条件向前搜索，已达到目标。当在探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的算法思想就是回溯算法。



> 算法模板

回溯算法通常使用递归实现（与树有关的算法一般都可以用递归实现）。

:bulb:：递归，分为递和归。



首先我们知道遍历一颗真正的多叉树方法如下：

```c
void traverse(TreeNode* root)
{
    if (root为空)
        return;
    
    for (TreeNode* child: children)
   		traverse(child);
}
```



```c
void backtrace(返回结果列表res, 选择列表selectList, 路径列表track)
{
    if 满足结束条件:
    	res.add(track)
    	return
        
    for 选择 in selectList:
        做选择，即将选择加入track
        backtrace(res, selectList, track)
        撤销选择，即将选择弹出track
    
}
```



`backtrace`函数其实就像一个指针，在这颗树上游走，同时要正确维护每个节点的属性。



















