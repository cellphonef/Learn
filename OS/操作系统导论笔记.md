# 操作系统导论笔记

## 操作系统介绍



程序运行时会发生什么？

1. 处理器从内存中取出（fetch）一条指令——取指。
2. 处理器对该指令进行解码（decode）——译码。
3. 处理器执行该指令（execute）——执行。
4. 处理器将指令执行的结果写回（write back）内存——写回。
5. 取下一条指令，循环以上步骤直到程序完成。



以上描述了冯诺依曼计算模型的基本概念。



**现代机器提供的物理内存模型非常简单。内存就是一个字节数组。要读取内存，必须指定一个地址，才能访问存储在那里的数据。要写入或更新内存，除了要指定地址外还要指定写入的数据。**







现在你已经了解了操作系统实际上做了什么：

- 它取得CPU、内存或磁盘等物理资源，并对他们进行虚拟化。
- 它处理并发有关的麻烦且棘手的问题。
- 它持久地存储文件，从而使他们长期安全。



## 第一部分：虚拟化

> 虚拟化——对实际情况进行封装，提供虚拟的假象。

虚拟化主要包含两个部分：

- CPU虚拟化——提供多个虚拟CPU的假象，每个程序运行好像独占一个CPU，不受其他程序影响。
- 内存虚拟化——提供多个虚拟内存的假象，每个程序运行好像独占一个内存，不受其他程序影响。

实现虚拟化需要机制和策略来共同完成：

- 机制：低级方法或协议，实现了所需的功能。
- 策略：高级算法，决定了如何使用功能。



### CPU虚拟化

> 目标：使系统更易于使用，CPU使用效率更高。

CPU虚拟化即将实际的CPU盖上虚拟的面纱然后提供多个虚拟CPU的假象。

CPU虚拟化的实现方式：时分共享CPU技术。即让一个程序只运行一个时间片，然后切换到其他程序运行。



#### 抽象：进程

> 为了虚拟化CPU首先引入一个抽象——进程

操作系统为正在运行的程序提供的抽象，就是所谓的进程。

程序本身是没有生命周期的，它只是存储在磁盘上面的指令序列（或者是静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。

进程











#### 插叙：进程API

**进程创建**

UNIX系统采用了一种非常有趣的创建新进程的方式，即通过一对系统调用：`fork()`和`exec()`。





**进程等待**

事实表明，有时候父进程需要等待子进程执行完毕，这很有用。

这项任务由`wait()`系统调用（或者更完整的兄弟接口`waitpid()`）。





#### 机制：受限直接执行

CPU虚拟化的实现方式即时分共享CPU（运行一个进程一段时间，然后运行另一个进程）。使用这种实现方式构建虚拟化机制应该满足以下两点：

- 尽可能保证性能。如何在不增加系统开销的情况下实现虚拟化。
- 必须保证控制权。如何有效地运行进程，同时保留对CPU的控制权。控制权对于操作系统尤为重要，因为操作系统负责资源管理。

首先，为了尽可能地保证进程运行效率，操作系统开发人员想出了一种技术——受限直接执行。

这个技术的“直接执行”部分很简单：即直接在CPU上执行程序。因此，当操作系统希望启动程序执行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码从磁盘加载到内存，跳转到入口点直接执行代码。

这种直接执行的方式使得进程的运行效率和未实现虚拟化之前一样高效，但是同样带来了一些问题：

- 问题一：如果我们只运行一个程序，操作系统怎么能确保程序不做任何我们不希望它做的事，同时仍然高效地运行它？
- 问题二：当我们运行一个进程时，操作系统如何让它停下来切换到另一个进程，从而实现时分共享CPU。

对这两个问题的回答，你将明白“受限”的部分来自哪里。

**问题一：受限制的操作**

直接执行的明显优势就是快速。该程序直接在硬件CPU上执行，因此执行速度与预期的一样快。但是，在CPU上运行会带来一个问题——如果进程希望执行某种受限操作（如磁盘发出I/O请求或获得更多系统资源如内存），这时该怎么办？

对于受限操作，最简单方法就是让所有进程做它们想做的事情。但是这样做将导致我们无法构建安全可靠的系统，例如某些恶意程序可以随意的利用这些操作摧毁系统。因此，我们采用的方法是引入一种新的处理器模式，称为用户模式（user mode）。在用户模式下运行的代码会受到限制，无法直接执行受限操作。但是用户确实希望执行某些受限操作，为了实现这一点，我们可以将受限操作交由值得信任的操作系统代为执行，用户如果希望执行某些操作可以使用操作系统提供的系统调用将具体操作转交给操作系统代为执行，操作系统会检查用户所希望的操作是否是被允许的，如果允许则会代为执行，否则将直接终止该进程，保证系统安全。为了执行受限操作，操作系统代码需要运行在内核模式（kernel mode）的处理器模式下，在该模式下的代码可以执行任何需要的特权操作。代为执行完进程希望的受限操作后返回到发起调用的用户进程中，同时将处理器模式变回用户模式，这样就能保住系统的安全同时完成进程希望执行的受限操作了。

关键点：

- 处理器至少提供两种模式：用户模式和内核模式，以区分用户和操作系统。
- 操作系统提供系统调用给用户程序使用，以满足用户的需要。



**问题二：在进程之间切换**

直接执行的另一个问题实现进程的切换。当进程在CPU上执行时，意味着操作系统并没有被执行，如果操作系统没有运行，它有如何实现进程切换？（实际上它不能）。因此，CPU运行其他进程时，操作系统必须有能力重新获取CPU的控制权。主要有两种方式，一种是协作方式，一种是非协作方式。

*协作方式：等待系统调用。*

系统调用发生时，会运行操作系统的代码，此时操作系统重获CPU控制权。但这种方式存在如下假设：系统的进程会合理的运行或者运行时执行了非法操作。运行时间过长的进程会定期放弃CPU。

虽然此法在某些情况下可行，但这样的操作系统会变得非常脆弱，因为它依赖于进程的行为。如果遇到一些恶意或设计错误的程序进入无限循环，并且从不进行系统调用，则此时操作系统将无能为力。



*非协作方式：操作系统进行控制*

对于协作方式，如果进程拒绝进行系统调用（也不执行非法操作）而不将控制权还给操作系统，那么操作系统将无法做任何事情。为了避免这种被动的方式，我们采取主动的方式，使用硬件的帮助来重获控制权：时钟中断。

我们可以利用时钟设备，将其编程为每隔一定时间产生一次中断。产生中断时，当前正在运行的进程将停止，操作系统中预先设置的中断处理程序会运行。此时，操作系统重新获得CPU的控制权（中断处理程序亦属于操作系统代码的一部分），因此可以做它想做的事情：停止当前进程，并启动另一个进程。



**保存和恢复上下文**

执行系统调用时，会进入内核模式并转而操作系统的代码，为了保证操作系统执行完成后能够正确返回到用户模式并执行用户代码，必须在执行操作系统代码前在某些位置（通常是内核栈）保存足够的调用者寄存器（例如程序计数器、标志和其他一些寄存器）。这样当系统调用完成后，可以从这些位置上（通常是内核栈）弹出这些寄存器值以恢复用户代码的执行。另外在系统调用期间，操作系统重获CPU控制权，它可以选择切换到其他进程运行，再切换其他进程运行之前，它也必须保存好足够的调用者寄存器，以便当该进程继续执行时能够恢复原状。

总结来说：

- 对于系统调用执行前，需要在内核栈中保存好调用者寄存器，以便从系统调用返回时能够正确返回。
- 对于系统调用执行过程中的进程切换，需要在进程控制块PCB中保存好调用者寄存器，以便当操作系统再次选择该进程运行时能够正确恢复现状。



**CPU虚拟化总结**

实现CPU虚拟化的关键就是受限直接执行：让程序运行的大部分指令直接访问硬件，只在一些关键点（如进程发起系统调用或发生时钟中断）由操作系统介入来确保“在正确的时间，正确的地点，做正确的事”。虚拟化的实现必须保证高效和控制，这是现代操作系统的两个主要目标。







#### 策略：进程调度







**多处理器调度**



关于一致性的概念，直观上可以定义为每个读操作必须返回最后写入此位置的值。对于每个处理器单元的操作都有一个总体的、串行的操作序是我们希望在任何一个一致性存储系统中见到的。因此，可以对高速缓存一致性进行一个更加形式化的定义方法：如果某个程序的任何执行结果都满足下列条件：对于任何单元，有可能建立一个假想的操作序列（也就是说，将所有进程发出的读写操作排成一个全序，此序列与执行结果一致，并且在序列中：（任何特定进程发出的操作所表现出来的序和该进程向存储系统发出它们的序相同，且每个读操作返回的值是对相应单元按照串行顺序写入的最后一值，那么此多处理器存储系统是一致性。



锁能够保证临界区在某一时刻只有一个线程活跃。





### 内存虚拟化

> 目标：使系统更易于使用，内存使用效率更高。



#### 抽象：地址空间



#### 插叙：内存操作API



#### 机制：地址转换





## 第二部分：并发

Q：为什么操作系统课要研究并发？

A：操作系统是第一个并发程序，许多技术都是在操作系统内部使用的。后来，在多线程的进程中，应用程序员也必须考虑这些事情。

### 抽象：线程





### 插叙：线程API

**线程创建**

```c
#include <pthread.h>
int pthread_create(pthread_t* thread,              // 线程handler。
                   pthread_attr_t* attr,           // 线程属性，一般传入NULL使用默认值即可。
                   void* (*start_routine)(void*),  // 函数指针，指示线程在那个函数运行。 
                   void* arg                       // 传递给函数的参数。
                  );
```





**线程汇合**

有时我们需要等待其他线程汇合，则此时必须调用函数`pthread_join()`。

```c
#include <pthread.h>
void pthread_join(pthread_t* thread)
```





**锁**

> 锁主要用来满足并发编程中原子性愿望。

```c
int pthread_mutex_lock(pthread_mutex_t* mutex);
int pthread_mutex_unlock(pthread_mutex_t* mutex);
```











**条件变量**

> 条件变量主要用来满足并发编程中顺序性愿望。

锁并不是并发程序设计所需的唯一原语，在很多情况下，线程需要检查某一条件满足之后，才会继续运行，这时就需要条件变量。

线程可以使用一个条件变量，来等待一个条件变成真。条件变量是一个显式队列，当某些条件不满足时，线程可以把自己加入队列，等待该条件满足。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让他们继续运行。

条件变量的`API`如下：

```c
pthread_cond_t c = PTHREAD_COND_INITIALIZER;    // 条件变量，使用静态初始化
pthread_cond_wait(pthread_cond_t* c, pthread_mutex_t* m);  // 在该条件上等待
pthread_cond_signal(pthread_cond_t* c);  // 唤醒等待该条件的线程
```

编写条件变量的代码有几个细节：

- 需要额外的状态来充当条件[1]。
- 尽量使用`while`而不是`if`来判断等待条件[2]。
- 调用`signal`（尽管有时不是严格需要，但这样简单有效）和`wait`（强制要求持有锁）时总是持有锁[3]。



### 锁





**实现锁**









Q：一定要记住，锁应该锁住的是共享数据，而不是代码，以便在某个操作访问共享数据时其他操作不可访问。为什么呢？

A：每个线程都有自己的状态，以及自己的栈，因此对于线程中的局部变量是不会受到其他线程的影响的，因此即使线程的各种执行顺序都有可能，但都不会对这些数据造成影响，进而也不会影响执行的结果，即对于线程私有的数据是自动线程安全的。而对于共享数据（全局变量，静态数据，以及堆数据），是所有线程都可以访问的，如果所有线程对于共享数据的访问都只是读而不会改变的话，那么线程的各种执行顺序不会影响结果，但如果有线程对共享数据更新时会出现两个问题：

- 某个线程执行时的某些操作依赖于那一时刻的共享数据的状态并利用该状态执行操作（读），如果其他线程改变了共享数据的状态（写）可能会导致程序出错。

- 某个线程执行时依赖的某些操作于那一时刻的共享数据的状态并对该状态进行更新（写），如果其他线程在该线程还未完成更新就读取该状态（读）或又进行更新（写）则程序也会出错。

以上两个问题十分类似，关键在于：当存在有线程会改变共享数据，而某个线程在使用共享数据时（读或写时），其他线程掺和进来也想使用共享数据（写或读），必将造成代码出错（读时不能写，写时不能读，写时不能写，另外理论上读时可以读，但是如果没有锁的保护，无法保证写不会穿插进来，因此一样会出错。）。因此我们需要保证这些线程的这些操作的原子性，即要么全部执行，要么没有执行，不存在中间状态。为此，我们在线程操作共享数据时为代码加上锁，只有持有锁的线程才能操作共享数据（即锁住共享数据），这样就可以避免以上问题。

> 使用锁的最简单方式就是把所有会访问共享数据的操作加锁，让原来的多线程变成单线程。





### 条件变量



**生产者/消费者（有界缓冲区）问题**

问题描述：假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区，消费者从缓冲区取走数据项，以某种方式消费。

问题分析：因为有界缓冲区是共享资源，所以我们必须通过同步机制来访问它，以免产生竞争条件。并且当缓冲区无数据时，消费者应该停下来，等生产者生成数据后再消费；反过来，当缓冲区数据满时，生产者应该停下来，等消费者消费数据后再生产，因此我们还要保证顺序。

代码：

```c
int buffer;     // 简单起见，先用一个int代替缓冲区
int count = 0;  // 用于表示缓冲区数据个数，初始为空。

// 将生产数据填入缓冲区
void put(int value)
{
    assert(count == 0);
    count = 1;
    buffer = value;
}

// 从缓冲区消费数据
int get()
{
    assert(count == 1);
    count = 0;
    return buffer;
}

// 生产者线程, 将一个整数放入缓冲区loops次
void* producer(void* arg)
{
    for (int i = 0; i < loops; i++) {
        put(i);
    }   
}

// 消费者线程，不停地从缓冲区取数据
void* consumer(void* arg)
{
    while (1) {
        int tmp = get();
        printf("%d\n", tmp);
    }   
}
```

有问题的方案：

```C
int loops = 1000;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

void* producer(void* arg) 
{
    for (int i = 0; i < loops; i++) {
        pthread_mutex_lock(&mutex);
        if (count == 1) {    // 使用if而不是while存在问题[2]
            pthread_cond_wait(&cond, &mutex);
        }
        put(i);
        pthread_cond_signal(&cond);
        pthread_mutex_unlock(&mutex);
    }
}

void* consumer(void* arg)
{
    while (1) {
        pthread_mutex_lock(&mutex);
        if (count == 0) {
            pthread_cond_wait(&cond, &mutex);
        }
        int tmp = get();
        pthread_cond_signal(&cond);
        pthread_mutex_unlock(&mutex);
        printf("%d\n", tmp);
    }
}

```

发信号给线程只是唤醒它们，暗示状态发生了变化，但并不保证在他运行之前状态一致是期望的状况。





较好但仍有问题的方案：使用While替代if

```c
int loops = 1000;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

void* producer(void* arg) 
{
    for (int i = 0; i < loops; i++) {
        pthread_mutex_lock(&mutex);
        while (count == 1) {    
            pthread_cond_wait(&cond, &mutex);  // 使用同一个条件变量存在问题
        }
        put(i);
        pthread_cond_signal(&cond);
        pthread_mutex_unlock(&mutex);
    }
}

void* consumer(void* arg)
{
    while (1) {
        pthread_mutex_lock(&mutex);
        while (count == 0) {
            pthread_cond_wait(&cond, &mutex);
        }
        int tmp = get();
        pthread_cond_signal(&cond);
        pthread_mutex_unlock(&mutex);
        printf("%d\n", tmp);
    }
}
```

正确的单值缓冲区的生产者/消费者方案



最终的生产者/消费者方案





### 信号量











### 常见并发问题

常见的并发问题主要有两类：

- 非死锁缺陷。
- 死锁缺陷。



**非死锁缺陷**

非死锁缺陷占了并发问题的大多数，其中主要包括两类：

- 违反原子性缺陷[1]。
- 错误顺序缺陷[2]。



[1]举例：

```c
// Thread 1:
if (thd->proc_info) {
	// ...
    fputs(thd->proc_info, ...);
    // ...
}

// Thread 2:
thd->proc_info = NULL;
```

这个例子中，两个线程都要访问`thd`结构中的成员`proc_info`。第一个线程检查`proc_info`非空，然后打印出值；第二个线程设置其为空。显然，当第一个线程检查之后，在`fputs()`调用之前，第二个线程把指针置为空；当第一个线程恢复执行时，由于引用空指针，导致程序崩溃。

这个例子就是明显的违反了原子性，即代码段本意是原子的，但在执行中并没有强制实现原子性，进而由于不可控的调度导致代码出错。这种问题的修复通常很简单，就是通过锁。我们利用锁，将共享的数据结构`proc_info`锁住，其他线程无法操作该结构，直到持有锁线程完成其操作，这样能确保线程在执行过程中，数据结构不会被意外修改，而是与程序预想的状态一致。

这里的关键问题是：如何将共享数据锁住？

答案是：将所有可能访问（读取或写入）这个共享数据的代码加上锁，只有持有锁才能访问共享数据。

```c
pthread_mutex_t proc_info_lock = PTHREAD_MUTEX_INITIALIZER;

// Thread 1:
pthread_mutex_lock(&proc_info_lock);
if (thd->proc_info) {
	// ...
    fputs(thd->proc_info, ...);
    // ...
}
pthread_mutex_unlock(&proc_info_lock);

// Thread 2:
pthread_mutex_lock(&proc_info_lock);
thd->proc_info = NULL;
pthread_mutex_unlock(&proc_info_lock);
```



[2]举例：

```c
// Thread 1:
void init() {
    // ...
    mThread = PR_CreateThread(mMain, ...);
    // ...
}

// Thread 2:
void mMain() {
    // ...
    mState = mThread->State;
    // ...
}
```

这个例子中，线程2的代码似乎假定变量`mThread`已经被初始化了。然而，如果线程1并没有首先执行，线程2就有可能引发空指针崩溃。

这个例子就是明显的错误顺序缺陷，代码段的本意是`init`首先执行完，然后再执行`mMain`，但是在执行中并没有强制顺序，进而由于不可控的调度导致代码出错。为了解决这个问题，我们需要强制顺序，而条件变量就是一种简单可靠的方式。

```c
pthread_mutex_t mtLock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t mtCond = PTHREAD_COND_INITIALIZER;
int mtInit = 0;

// Thread 1:
void init() {
    // ...
    mThread = PR_CreateThread(mMain, ...);
    // ...
    pthread_mutex_lock(&mtLock);
    mtInit = 1;
    pthread_cond_signal(&mtCond);
    pthread_mutex_unlock(&mtLock);
}

// Thread 2:
void mMain() {
    // ...
    pthread_mutex_lock(&mtLock);
    while (mtInit == 0) {
        pthread_cond_wait(&mtCond, &mtLock);
    }
    pthread_mutex_unlock(&mtLock);
    mState = mThread->State;
    // ...
}
```





**死锁缺陷**



死锁产生的四个条件：

* 互斥访问。
* 持有并等待。
* 非抢占。
* 循环等待。



## 第三部分：持久化





### 插叙：文件和目录

随着时间的推移，存储虚拟化形成了两个关键的抽象：

- 文件。
- 目录。

文件就是一个线性字节数组，每个字节都可以读取或写入。每个文件都有一个低级名称inode号，与文件一一对应。

目录，属于特殊文件，它也有一个低级名称inode号与之唯一对应。目录的内容非常具体：它包含一个（用户可读名字，inode号）对的列表。目录中的每个条目都指向文件或其他目录。通过将目录放入其他目录中，用户可以构建任意的目录树，或目录层次结构，该目录下存储所有文件和目录。

#### 文件系统接口

**创建文件**

创建文件有两种方式：

- 通过调用`open()`并传入`O_CREAT`标志（一般都使用`open`，创建的同时打开文件返回文件描述符）。
- 通过调用`creat()`，相当于`open()`加上`O_CREAT|O_WRONLY|O_TRUNC`。



**读写文件**

读写文件通过两个系统调用：

- `read`
- `write`

```c
#include <unistd.h>

// fd: 待读取的文件描述符
// buf: 存放读取数据的缓存区
// count: 读取数据的字节数（请求）
// return value: 成功读取到的字节数（可能小于count），-1表示失败并设置errno，0表示到达文件尾eof
ssize_t read(int fd, void* buf, size_t count);

// fd: 待写的文件描述符
// buf: 存放写数据的缓存区
// count: 写入数据的字节数（请求）
// return value: 成功写入的字节数（可能小于count），-1表示失败，0
ssize_t write(int fd, void* buf, size_t count);

```





**fsync立即写入**

大多数情况下，当程序调用`write()`时，它只是告诉操作系统：请在将来的某个时刻，将此数据写入持久存储。出于性能的原因，文件系统会将这些数据写入在内存中缓冲一段时间。在稍后的事件点，写入将实际发送到存储设备。而当用户数据写入缓冲后系统调用`write()`就返回了，让用户以为已经成功写入。

了解了实际情况后，有些应用程序需要的可能不只是这种保证，它们需要能够立即强制写入磁盘。在UNIX中，可以使用`fsync(int fd)`来立即强制写入磁盘。当进程针对特定文件描述符调用`fsync`时，操作系统将通过强制将指定文件描述符引用的文件的脏数据写入磁盘来响应。一旦所有这些写入完成，`fsync`就会返回。

```C
#include <unistd.h>

// fd: 文件描述符
// return value: 成功返回0，失败返回-1并设置errno 
int fsync(int fd);
```





**调整文件指针偏移**

调整文件指针偏移，我们将使用`lseek()`系统调用。

```c
#include <unistd.h>

// fd: 文件描述符
// offset: 偏移量
// whence: 基址
// return value: 成功返回当前偏移量，失败返回-1并设置errno
off_t lseek(int fd, off_t offset, int whence);
```





**文件重命名**

文件重命名，我们将使用`rename()`系统调用。

```c
// old: 原来名字
// new: 新名称
rename(char* old, char* new);
```



**获取文件信息**

除了文件访问之外，我们还希望文件系统能够保存关于它正在存储的每个文件的大量信息（文件元数据）。要查看特定文件的元数据，我们可以使用`stat()`或`fstat()`系统调用。

```c
#include <sys/stat.h>

// pathname: 待查看路径名
// statbuf: 存放文件信息缓冲
// return value: 成功返回0，失败返回-1并设置errno
int stat(const char* pathname, struct stat* statbuf);
```





**删除文件**

删除文件对应的系统调用为`unlink()`，为什么是unlink而不是remove或delete？这是链接的缘故。

```c
#include <unistd.h>

// pathname: 待删除路径名
// return value: 成功返回0，失败返回-并设置errno
int unlink(const char* pathname);
```



**创建目录**

要创建目录，可以用系统调用`mkdir()`。这样创建的目录，它被认为是"空的"，尽管它实际上包含最少的内容（"."和".."）。

```c
#include <sys/stat.h>

// pathname: 待创建目录名
// mode: 目录权限
// return value: 成功返回0，失败返回-1并设置errno
int mkdir(const char* pathname, mode_t mode)
```







**读取目录**

不是像打开文件一样打开一个目录，而是使用一组新的调用：

- opendir
- readdir
- closedir







**删除目录**

你可以通过`rmdir()`来删除目录。然而，与删除文件不同，删除目录更加危险，因为你删除目录后对应目录下的文件可能也会被删除。因此，`rmdir()`要求该目录在被删除之前是空的（只有"."和".."）。如果你试图删除一个非空目录，那么对`rmdir()`的调用将会失败。



**硬链接**



`link`只是在要创建链接的目录中创建另一个名称，并将其指向原有文件的相同的inode号，并不会创建新的文件。



硬链接存在某些局限，例如：

- 不能创建目录的链接（因为担心会在目录树中创建一个环）。

- 由于inode号对于每个文件系统是唯一的，不能跨越文件系统。



**符号链接**

为了弥补硬链接的问题，出现了另一个链接：符号链接。

为了能够跨越文件系统，符号链接将生成一个真正的"链接"类型的文件，而该文件保存着被链接文件的路径。



不过符号链接也有一个问题：

- 悬空引用，删除被链接的文件将导致符号链接指向不在存在的路径名。





**创建并挂载文件系统**

我们还应该讨论另一个话题：如何从许多底层文件系统组建完整的目录树。

这项任务的实现分两步：

1. 制作文件系统（使用`mkfs`）。
2. 将文件系统挂载到目录树上（使用`mount`）。

当文件系统挂载到目录树上后，我们访问该目录树就会访问对应的文件系统。

> Linux文件目录树是由各种文件系统拼凑起来的。









### 文件系统的实现







