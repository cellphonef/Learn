# 操作系统导论笔记

## 操作系统介绍



程序运行时会发生什么？

1. 处理器从内存中取出（fetch）一条指令——取指。
2. 处理器对该指令进行解码（decode）——译码。
3. 处理器执行该指令（execute）——执行。
4. 处理器将指令执行的结果写回（write back）内存——写回。
5. 取下一条指令，循环以上步骤直到程序完成。



以上描述了冯诺依曼计算模型的基本概念。



**现代机器提供的物理内存模型非常简单。内存就是一个字节数组。要读取内存，必须指定一个地址，才能访问存储在那里的数据。要写入或更新内存，除了要指定地址外还要指定写入的数据。**







现在你已经了解了操作系统实际上做了什么：

- 它取得CPU、内存或磁盘等物理资源，并对他们进行虚拟化。
- 它处理并发有关的麻烦且棘手的问题。
- 它持久地存储文件，从而使他们长期安全。



## 第一部分：虚拟化

> 虚拟化——对实际情况进行封装，提供虚拟的假象。

虚拟化主要包含两个部分：

- CPU虚拟化——提供多个虚拟CPU的假象，每个程序运行好像独占一个CPU，不受其他程序影响。
- 内存虚拟化——提供多个虚拟内存的假象，每个程序运行好像独占一个内存，不受其他程序影响。

实现虚拟化需要机制和策略来共同完成：

- 机制：低级方法或协议，实现了所需的功能。
- 策略：高级算法，决定了如何使用功能。



### CPU虚拟化

> 目标：使系统更易于使用，CPU使用效率更高。

CPU虚拟化即将实际的CPU盖上虚拟的面纱然后提供多个虚拟CPU的假象。

CPU虚拟化的实现方式：时分共享CPU技术。即让一个程序只运行一个时间片，然后切换到其他程序运行。



#### 抽象：进程

> 为了虚拟化CPU首先引入一个抽象——进程

操作系统为正在运行的程序提供的抽象，就是所谓的进程。

程序本身是没有生命周期的，它只是存储在磁盘上面的指令序列（或者是静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。

进程











#### 插叙：进程API

**进程创建**

UNIX系统采用了一种非常有趣的创建新进程的方式，即通过一对系统调用：`fork()`和`exec()`。





**进程等待**

事实表明，有时候父进程需要等待子进程执行完毕，这很有用。

这项任务由`wait()`系统调用（或者更完整的兄弟接口`waitpid()`）。





#### 机制：受限直接执行

CPU虚拟化的实现方式即时分共享CPU（运行一个进程一段时间，然后运行另一个进程）。使用这种实现方式构建虚拟化机制应该满足以下两点：

- 尽可能保证性能。如何在不增加系统开销的情况下实现虚拟化。
- 必须保证控制权。如何有效地运行进程，同时保留对CPU的控制权。控制权对于操作系统尤为重要，因为操作系统负责资源管理。

首先，为了尽可能地保证进程运行效率，操作系统开发人员想出了一种技术——受限直接执行。

这个技术的“直接执行”部分很简单：即直接在CPU上执行程序。因此，当操作系统希望启动程序执行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码从磁盘加载到内存，跳转到入口点直接执行代码。

这种直接执行的方式使得进程的运行效率和未实现虚拟化之前一样高效，但是同样带来了一些问题：

- 问题一：如果我们只运行一个程序，操作系统怎么能确保程序不做任何我们不希望它做的事，同时仍然高效地运行它？
- 问题二：当我们运行一个进程时，操作系统如何让它停下来切换到另一个进程，从而实现时分共享CPU。

对这两个问题的回答，你将明白“受限”的部分来自哪里。

**问题一：受限制的操作**

直接执行的明显优势就是快速。该程序直接在硬件CPU上执行，因此执行速度与预期的一样快。但是，在CPU上运行会带来一个问题——如果进程希望执行某种受限操作（如磁盘发出I/O请求或获得更多系统资源如内存），这时该怎么办？

对于受限操作，最简单方法就是让所有进程做它们想做的事情。但是这样做将导致我们无法构建安全可靠的系统，例如某些恶意程序可以随意的利用这些操作摧毁系统。因此，我们采用的方法是引入一种新的处理器模式，称为用户模式（user mode）。在用户模式下运行的代码会受到限制，无法直接执行受限操作。但是用户确实希望执行某些受限操作，为了实现这一点，我们可以将受限操作交由值得信任的操作系统代为执行，用户如果希望执行某些操作可以使用操作系统提供的系统调用将具体操作转交给操作系统代为执行，操作系统会检查用户所希望的操作是否是被允许的，如果允许则会代为执行，否则将直接终止该进程，保证系统安全。为了执行受限操作，操作系统代码需要运行在内核模式（kernel mode）的处理器模式下，在该模式下的代码可以执行任何需要的特权操作。代为执行完进程希望的受限操作后返回到发起调用的用户进程中，同时将处理器模式变回用户模式，这样就能保住系统的安全同时完成进程希望执行的受限操作了。

关键点：

- 处理器至少提供两种模式：用户模式和内核模式，以区分用户和操作系统。
- 操作系统提供系统调用给用户程序使用，以满足用户的需要。



**问题二：在进程之间切换**

直接执行的另一个问题实现进程的切换。当进程在CPU上执行时，意味着操作系统并没有被执行，如果操作系统没有运行，它有如何实现进程切换？（实际上它不能）。因此，CPU运行其他进程时，操作系统必须有能力重新获取CPU的控制权。主要有两种方式，一种是协作方式，一种是非协作方式。

*协作方式：等待系统调用。*

系统调用发生时，会运行操作系统的代码，此时操作系统重获CPU控制权。但这种方式存在如下假设：系统的进程会合理的运行或者运行时执行了非法操作。运行时间过长的进程会定期放弃CPU。

虽然此法在某些情况下可行，但这样的操作系统会变得非常脆弱，因为它依赖于进程的行为。如果遇到一些恶意或设计错误的程序进入无限循环，并且从不进行系统调用，则此时操作系统将无能为力。



*非协作方式：操作系统进行控制*

对于协作方式，如果进程拒绝进行系统调用（也不执行非法操作）而不将控制权还给操作系统，那么操作系统将无法做任何事情。为了避免这种被动的方式，我们采取主动的方式，使用硬件的帮助来重获控制权：时钟中断。

我们可以利用时钟设备，将其编程为每隔一定时间产生一次中断。产生中断时，当前正在运行的进程将停止，操作系统中预先设置的中断处理程序会运行。此时，操作系统重新获得CPU的控制权（中断处理程序亦属于操作系统代码的一部分），因此可以做它想做的事情：停止当前进程，并启动另一个进程。



**保存和恢复上下文**

执行系统调用时，会进入内核模式并转而操作系统的代码，为了保证操作系统执行完成后能够正确返回到用户模式并执行用户代码，必须在执行操作系统代码前在某些位置（通常是内核栈）保存足够的调用者寄存器（例如程序计数器、标志和其他一些寄存器）。这样当系统调用完成后，可以从这些位置上（通常是内核栈）弹出这些寄存器值以恢复用户代码的执行。另外在系统调用期间，操作系统重获CPU控制权，它可以选择切换到其他进程运行，再切换其他进程运行之前，它也必须保存好足够的调用者寄存器，以便当该进程继续执行时能够恢复原状。

总结来说：

- 对于系统调用执行前，需要在内核栈中保存好调用者寄存器，以便从系统调用返回时能够正确返回。
- 对于系统调用执行过程中的进程切换，需要在进程控制块PCB中保存好调用者寄存器，以便当操作系统再次选择该进程运行时能够正确恢复现状。



**CPU虚拟化总结**

实现CPU虚拟化的关键就是受限直接执行：让程序运行的大部分指令直接访问硬件，只在一些关键点（如进程发起系统调用或发生时钟中断）由操作系统介入来确保“在正确的时间，正确的地点，做正确的事”。虚拟化的实现必须保证高效和控制，这是现代操作系统的两个主要目标。







#### 策略：进程调度







**多处理器调度**



关于一致性的概念，直观上可以定义为每个读操作必须返回最后写入此位置的值。对于每个处理器单元的操作都有一个总体的、串行的操作序是我们希望在任何一个一致性存储系统中见到的。因此，可以对高速缓存一致性进行一个更加形式化的定义方法：如果某个程序的任何执行结果都满足下列条件：对于任何单元，有可能建立一个假想的操作序列（也就是说，将所有进程发出的读写操作排成一个全序，此序列与执行结果一致，并且在序列中：（任何特定进程发出的操作所表现出来的序和该进程向存储系统发出它们的序相同，且每个读操作返回的值是对相应单元按照串行顺序写入的最后一值，那么此多处理器存储系统是一致性。



锁能够保证临界区在某一时刻只有一个线程活跃。





### 内存虚拟化

> 目标：使系统更易于使用，内存使用效率更高。



#### 抽象：地址空间



#### 插叙：内存操作API



#### 机制：地址转换





## 第二部分：并发

Q：为什么操作系统课要研究并发？

A：操作系统是第一个并发程序，许多技术都是在操作系统内部使用的。后来，在多线程的进程中，应用程序员也必须考虑这些事情。

### 抽象：线程





### 插叙：线程API

**线程创建**



**线程汇合**



**锁**



**条件变量**







