# 操作系统导论笔记

## 操作系统介绍



程序运行时会发生什么？

1. 处理器从内存中取出（fetch）一条指令——取指。
2. 处理器对该指令进行解码（decode）——译码。
3. 处理器执行该指令（execute）——执行。
4. 处理器将指令执行的结果写回（write back）内存——写回。
5. 取下一条指令，循环以上步骤直到程序完成。



以上描述了冯诺依曼计算模型的基本概念。



**现代机器提供的物理内存模型非常简单。内存就是一个字节数组。要读取内存，必须指定一个地址，才能访问存储在那里的数据。要写入或更新内存，除了要指定地址外还要指定写入的数据。**







现在你已经了解了操作系统实际上做了什么：

- 它取得CPU、内存或磁盘等物理资源，并对他们进行虚拟化。
- 它处理并发有关的麻烦且棘手的问题。
- 它持久地存储文件，从而使他们长期安全。



## 第一部分：虚拟化

> 虚拟化——对实际情况进行封装，提供虚拟的假象。

虚拟化主要包含两个部分：

- CPU虚拟化——提供多个虚拟CPU的假象，每个程序运行好像独占一个CPU，不受其他程序影响。
- 内存虚拟化——提供多个虚拟内存的假象，每个程序运行好像独占一个内存，不受其他程序影响。

实现虚拟化需要机制和策略来共同完成：

- 机制：低级方法或协议，实现了所需的功能。
- 策略：高级算法，决定了如何使用功能。



### CPU虚拟化

> 目标：使系统更易于使用，CPU使用效率更高。

CPU虚拟化即将实际的CPU盖上虚拟的面纱然后提供多个虚拟CPU的假象。

CPU虚拟化的实现方式：时分共享CPU技术。即让一个程序只运行一个时间片，然后切换到其他程序运行。



#### 抽象：进程

> 为了虚拟化CPU首先引入一个抽象——进程

操作系统为正在运行的程序提供的抽象，就是所谓的进程。

程序本身是没有生命周期的，它只是存储在磁盘上面的指令序列（或者是静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。

进程











#### 插叙：进程API

**进程创建**

UNIX系统采用了一种非常有趣的创建新进程的方式，即通过一对系统调用：`fork()`和`exec()`。





**进程等待**

事实表明，有时候父进程需要等待子进程执行完毕，这很有用。

这项任务由`wait()`系统调用（或者更完整的兄弟接口`waitpid()`）。





#### 机制：受限直接执行

CPU虚拟化的实现方式即时分共享CPU（运行一个进程一段时间，然后运行另一个进程）。使用这种实现方式构建虚拟化机制应该满足以下两点：

- 尽可能保证性能。如何在不增加系统开销的情况下实现虚拟化。
- 必须保证控制权。如何有效地运行进程，同时保留对CPU的控制权。控制权对于操作系统尤为重要，因为操作系统负责资源管理。

首先，为了尽可能地保证进程运行效率，操作系统开发人员想出了一种技术——受限直接执行。

这个技术的“直接执行”部分很简单：即直接在CPU上执行程序。因此，当操作系统希望启动程序执行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码从磁盘加载到内存，跳转到入口点直接执行代码。

这种直接执行的方式使得进程的运行效率和未实现虚拟化之前一样高效，但是同样带来了一些问题：

- 问题一：如果我们只运行一个程序，操作系统怎么能确保程序不做任何我们不希望它做的事，同时仍然高效地运行它？
- 问题二：当我们运行一个进程时，操作系统如何让它停下来切换到另一个进程，从而实现时分共享CPU。

对这两个问题的回答，你将明白“受限”的部分来自哪里。

**问题一：受限制的操作**

直接执行的明显优势就是快速。该程序直接在硬件CPU上执行，因此执行速度与预期的一样快。但是，在CPU上运行会带来一个问题——如果进程希望执行某种受限操作（如磁盘发出I/O请求或获得更多系统资源如内存），这时该怎么办？

对于受限操作，最简单方法就是让所有进程做它们想做的事情。但是这样做将导致我们无法构建安全可靠的系统，例如某些恶意程序可以随意的利用这些操作摧毁系统。因此，我们采用的方法是引入一种新的处理器模式，称为用户模式（user mode）。在用户模式下运行的代码会受到限制，无法直接执行受限操作。但是用户确实希望执行某些受限操作，为了实现这一点，我们可以将受限操作交由值得信任的操作系统代为执行，用户如果希望执行某些操作可以使用操作系统提供的系统调用将具体操作转交给操作系统代为执行，操作系统会检查用户所希望的操作是否是被允许的，如果允许则会代为执行，否则将直接终止该进程，保证系统安全。为了执行受限操作，操作系统代码需要运行在内核模式（kernel mode）的处理器模式下，在该模式下的代码可以执行任何需要的特权操作。代为执行完进程希望的受限操作后返回到发起调用的用户进程中，同时将处理器模式变回用户模式，这样就能保住系统的安全同时完成进程希望执行的受限操作了。

关键点：

- 处理器至少提供两种模式：用户模式和内核模式，以区分用户和操作系统。
- 操作系统提供系统调用给用户程序使用，以满足用户的需要。



**问题二：在进程之间切换**

直接执行的另一个问题实现进程的切换。当进程在CPU上执行时，意味着操作系统并没有被执行，如果操作系统没有运行，它有如何实现进程切换？（实际上它不能）。因此，CPU运行其他进程时，操作系统必须有能力重新获取CPU的控制权。主要有两种方式，一种是协作方式，一种是非协作方式。

*协作方式：等待系统调用。*

系统调用发生时，会运行操作系统的代码，此时操作系统重获CPU控制权。但这种方式存在如下假设：系统的进程会合理的运行或者运行时执行了非法操作。运行时间过长的进程会定期放弃CPU。

虽然此法在某些情况下可行，但这样的操作系统会变得非常脆弱，因为它依赖于进程的行为。如果遇到一些恶意或设计错误的程序进入无限循环，并且从不进行系统调用，则此时操作系统将无能为力。



*非协作方式：操作系统进行控制*

对于协作方式，如果进程拒绝进行系统调用（也不执行非法操作）而不将控制权还给操作系统，那么操作系统将无法做任何事情。为了避免这种被动的方式，我们采取主动的方式，使用硬件的帮助来重获控制权：时钟中断。

我们可以利用时钟设备，将其编程为每隔一定时间产生一次中断。产生中断时，当前正在运行的进程将停止，操作系统中预先设置的中断处理程序会运行。此时，操作系统重新获得CPU的控制权（中断处理程序亦属于操作系统代码的一部分），因此可以做它想做的事情：停止当前进程，并启动另一个进程。



**保存和恢复上下文**

执行系统调用时，会进入内核模式并转而操作系统的代码，为了保证操作系统执行完成后能够正确返回到用户模式并执行用户代码，必须在执行操作系统代码前在某些位置（通常是内核栈）保存足够的调用者寄存器（例如程序计数器、标志和其他一些寄存器）。这样当系统调用完成后，可以从这些位置上（通常是内核栈）弹出这些寄存器值以恢复用户代码的执行。另外在系统调用期间，操作系统重获CPU控制权，它可以选择切换到其他进程运行，再切换其他进程运行之前，它也必须保存好足够的调用者寄存器，以便当该进程继续执行时能够恢复原状。

总结来说：

- 对于系统调用执行前，需要在内核栈中保存好调用者寄存器，以便从系统调用返回时能够正确返回。
- 对于系统调用执行过程中的进程切换，需要在进程控制块PCB中保存好调用者寄存器，以便当操作系统再次选择该进程运行时能够正确恢复现状。



**CPU虚拟化总结**

实现CPU虚拟化的关键就是受限直接执行：让程序运行的大部分指令直接访问硬件，只在一些关键点（如进程发起系统调用或发生时钟中断）由操作系统介入来确保“在正确的时间，正确的地点，做正确的事”。虚拟化的实现必须保证高效和控制，这是现代操作系统的两个主要目标。







#### 策略：进程调度







**多处理器调度**



关于一致性的概念，直观上可以定义为每个读操作必须返回最后写入此位置的值。对于每个处理器单元的操作都有一个总体的、串行的操作序是我们希望在任何一个一致性存储系统中见到的。因此，可以对高速缓存一致性进行一个更加形式化的定义方法：如果某个程序的任何执行结果都满足下列条件：对于任何单元，有可能建立一个假想的操作序列（也就是说，将所有进程发出的读写操作排成一个全序，此序列与执行结果一致，并且在序列中：（任何特定进程发出的操作所表现出来的序和该进程向存储系统发出它们的序相同，且每个读操作返回的值是对相应单元按照串行顺序写入的最后一值，那么此多处理器存储系统是一致性。



锁能够保证临界区在某一时刻只有一个线程活跃。





### 内存虚拟化

> 目标：使系统更易于使用，内存使用效率更高。



#### 抽象：地址空间



#### 插叙：内存操作API



#### 机制：地址转换





## 第二部分：并发

Q：为什么操作系统课要研究并发？

A：操作系统是第一个并发程序，许多技术都是在操作系统内部使用的。后来，在多线程的进程中，应用程序员也必须考虑这些事情。

### 抽象：线程





### 插叙：线程API

**线程创建**



**线程汇合**



**锁**

> 锁主要用来满足并发编程中原子性愿望。





Q：一定要记住，锁应该锁住的是共享数据，而不是代码，以便在某个操作访问共享数据时其他操作不可访问。为什么呢？

A：每个线程都有自己的状态，以及自己的栈，因此对于线程中的局部变量是不会受到其他线程的影响的，因此即使线程的各种执行顺序都有可能，但都不会对这些数据造成影响，进而也不会影响执行的结果，即对于线程私有的数据是自动线程安全的。而对于共享数据（全局变量，静态数据，以及堆数据），是所有线程都可以访问的，如果所有线程对于共享数据的访问都只是读而不会改变的话，那么线程的各种执行顺序不会影响结果，但如果有线程对共享数据更新时会出现两个问题：

- 某个线程执行时的某些操作依赖于那一时刻的共享数据的状态并利用该状态执行操作（读），如果其他线程改变了共享数据的状态（写）可能会导致程序出错。

- 某个线程执行时依赖的某些操作于那一时刻的共享数据的状态并对该状态进行更新（写），如果其他线程在该线程还未完成更新就读取该状态（读）或又进行更新（写）则程序也会出错。

以上两个问题十分类似，关键在于：当存在有线程会改变共享数据，而某个线程在使用共享数据时（读或写时），其他线程掺和进来也想使用共享数据（写或读），必将造成代码出错（读时不能写，写时不能读，写时不能写，另外理论上读时可以读，但是如果没有锁的保护，无法保证写不会穿插进来，因此一样会出错。）。因此我们需要保证这些线程的这些操作的原子性，即要么全部执行，要么没有执行，不存在中间状态。为此，我们在线程操作共享数据时为代码加上锁，只有持有锁的线程才能操作共享数据（即锁住共享数据），这样就可以避免以上问题。





**条件变量**

> 条件变量主要用来满足并发编程中顺序性愿望。

锁并不是并发程序设计所需的唯一原语，在很多情况下，线程需要检查某一条件满足之后，才会继续运行，这时就需要条件变量。

线程可以使用一个条件变量，来等待一个条件变成真。条件变量是一个显式队列，当某些条件不满足时，线程可以把自己加入队列，等待该条件满足。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让他们继续运行。

条件变量的`API`如下：

```c
pthread_cond_t c = PTHREAD_COND_INITIALIZER;    // 条件变量，使用静态初始化
pthread_cond_wait(pthread_cond_t* c, pthread_mutex_t* m);  // 在该条件上等待
pthread_cond_signal(pthread_cond_t* c);  // 唤醒等待该条件的线程
```

编写条件变量的代码有几个细节：

- 需要额外的状态来充当条件[1]。

- 尽量使用`while`而不是`if`来判断等待条件[2]。
- 调用`signal`（尽管有时不是严格需要，但这样简单有效）和`wait`（强制要求持有锁）时总是持有锁[3]。

[1]举例：

```c

```



[2]举例

发信号给线程只是唤醒它们，暗示状态发生了变化，但并不保证在他运行之前状态一致是期望的状况。





[3]举例







### 常见并发问题

常见的并发问题主要有两类：

- 非死锁缺陷。
- 死锁缺陷。



**非死锁缺陷**

非死锁缺陷占了并发问题的大多数，其中主要包括两类：

- 违反原子性缺陷[1]。
- 错误顺序缺陷[2]。



[1]举例：

```c
// Thread 1:
if (thd->proc_info) {
	// ...
    fputs(thd->proc_info, ...);
    // ...
}

// Thread 2:
thd->proc_info = NULL;
```

这个例子中，两个线程都要访问`thd`结构中的成员`proc_info`。第一个线程检查`proc_info`非空，然后打印出值；第二个线程设置其为空。显然，当第一个线程检查之后，在`fputs()`调用之前，第二个线程把指针置为空；当第一个线程恢复执行时，由于引用空指针，导致程序崩溃。

这个例子就是明显的违反了原子性，即代码段本意是原子的，但在执行中并没有强制实现原子性，进而由于不可控的调度导致代码出错。这种问题的修复通常很简单，就是通过锁。我们利用锁，将共享的数据结构`proc_info`锁住，其他线程无法操作该结构，直到持有锁线程完成其操作，这样能确保线程在执行过程中，数据结构不会被意外修改，而是与程序预想的状态一致。

这里的关键问题是：如何将共享数据锁住？

答案是：将所有可能访问（读取或写入）这个共享数据的代码加上锁，只有持有锁才能访问共享数据。

```c
pthread_mutex_t proc_info_lock = PTHREAD_MUTEX_INITIALIZER;

// Thread 1:
pthread_mutex_lock(&proc_info_lock);
if (thd->proc_info) {
	// ...
    fputs(thd->proc_info, ...);
    // ...
}
pthread_mutex_unlock(&proc_info_lock);

// Thread 2:
pthread_mutex_lock(&proc_info_lock);
thd->proc_info = NULL;
pthread_mutex_unlock(&proc_info_lock);
```



[2]举例：

```c
// Thread 1:
void init() {
    // ...
    mThread = PR_CreateThread(mMain, ...);
    // ...
}

// Thread 2:
void mMain() {
    // ...
    mState = mThread->State;
    // ...
}
```

这个例子中，线程2的代码似乎假定变量`mThread`已经被初始化了。然而，如果线程1并没有首先执行，线程2就有可能引发空指针崩溃。

这个例子就是明显的错误顺序缺陷，代码段的本意是`init`首先执行完，然后再执行`mMain`，但是在执行中并没有强制顺序，进而由于不可控的调度导致代码出错。为了解决这个问题，我们需要强制顺序，而条件变量就是一种简单可靠的方式。

```c
pthread_mutex_t mtLock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t mtCond = PTHREAD_COND_INITIALIZER;
int mtInit = 0;

// Thread 1:
void init() {
    // ...
    mThread = PR_CreateThread(mMain, ...);
    // ...
    pthread_mutex_lock(&mtLock);
    mtInit = 1;
    pthread_cond_signal(&mtCond);
    pthread_mutex_unlock(&mtLock);
}

// Thread 2:
void mMain() {
    // ...
    pthread_mutex_lock(&mtLock);
    while (mtInit == 0) {
        pthread_cond_wait(&mtCond, &mtLock);
    }
    pthread_mutex_unlock(&mtLock);
    mState = mThread->State;
    // ...
}
```





**死锁缺陷**



死锁产生的四个条件：

* 互斥访问。
* 持有并等待。
* 非抢占。
* 循环等待。



## 第三部分：持久化

