

## 并发基础知识

### SMP

SMP, 即Symmetric multiprocessing或Shared-memory multiprocessing。






### 缓存结构(Cache Structure)

现代CPU的速度是远远超过现代内存系统的。一个2006年的CPU可能能够在每毫微秒执行十条指令，但是可能需要几十毫微秒才能从内存获取一个数据项。这种速度的极大差异——超过两个数量级，导致含多个MB的缓存出现在现代CPU中。这些缓存与CPU的关系如图1所示，它们可以在几个周期进行访问。

在CPU缓存和内存之间的数据流是固定大小的块（通常是2的幂，16到256字节）称为"cache lines"。当一个给定的数据项被一个给定的CPU第一次访问时，CPU缓存还没有该数据项，此时会发生"cache miss"。cache miss意味着CPU需要等待几百个周期从内存中取出对应的数据项。不管怎样，这个数据项最终都会被载入到CPU的缓存中，这将使得后续对该数据项的访问都能在缓存中获取，因此速度将得到很大提升。

经过一段时间后，CPU的缓存将满载，于是后续的cache miss可能需要从缓存中弹出一个cache line以便给新的数据项腾出空间。这种类型的cache miss可以称为"capacity miss"，因为它是因为缓存有限的容量引起的。


到目前为止，我们只考虑了CPU读取数据项时的情况。那当CPU写数据时会发生什么？由于在某个CPU修改数据项之前，对于所有CPU来说它们认为该数据项的值都是一致的，所以如果要修改该数据项，首先要做的就是使所有其他CPU缓存中该数据项失效（避免读取到旧值，保证一致）。一旦这些失效操作全部完成，CPU才能安全的修改数据项。





MESI States

MESI是指"modified"、"exclusive"、"shared"、"invalid"。

cache line处于modified状态是指：
- 该CPU独占该cache line。
- 该cache line和内存中的数据不一致。
- 该CPU必须对该cache line负责，它需要负责将其写回内存或负责将该cache line转交给其他CPU，并且需要在该cache line被替换出去之前完成。


cache line处于exclusive状态是指：
- 该CPU独占该cache line。
- 该cache line和内存中的数据保持一致。
- 该CPU可以直接丢弃该cache line而不需要写回，或者将其cache line转交给其他CPU


cache line处于shared状态是指：
- 其他至少一个CPU中都有也该cache line。
- 该cache line和内存中的数据保持一致。



cache line处于invalid是指：
- 该cache line为空，没有有效数据。


因为所有CPU必须保持缓存的一致性，于是有了缓存一致性协议，该协议提供协调系统中缓存动作的各种信息。

MESI协议信息

以上描述的状态，如果要发生转变则需要在所有CPU进行通信。如果所有CPU使用的是单一的共享总线，则以下的信息就足够满足需要了：
- "read" message。"read" message包括需要读取到cache line的物理地址。
- "read response" message。"read response" message包括之前收到的"read" message所请求的数据。"read response" message可能由内存或其他缓存提供。例如，拥有请求数据的缓存行状态为"modified"，则这个cache必须负责提供该"read response" message。
-  "invalidate" message。"invalidate" message包括需要失效的cache line的物理地址，所有其他cache必须失效掉对应物理地址的cache line并回复。
- "invalidate acknowledge" message。任何收到"invalidate" message的CPU都应该将其对应物理地址的cache line失效后发送"invalidate acknowledge" message。
- "read invalidate" message。"read invalidate" message包括需要读入cache line的物理地址，并与此同时让其他cache丢弃该数据。因此该message的效果就如同"read" message和"invalidate" message结合。因此该message需要接收"read response" message以及一系列"invalidate acknowledge" message作为回应。
- "writeback" message。"writeback" message包括需要写回内存的物理地址和数据。该message允许cache丢弃处于"modified"状态的cache line来为其他数据腾出空间。





MESI状态转换图


转换(a): 一个cache line被写回内存，但是CPU决定继续保留该cache line以便进一步保留修改该cache line的权利。这个转换需要"writeback" message。

转换(b): CPU向其有独占访问权的cache line写入数据。这个转换不需要任何message。

转换(c): 该CPU接收到对于处于"modified"状态的cache line的"read invalidate" message。该CPU必须使该cache line失效，并发送"read response" message和"invalidate acknowledge" message。

转换(d): 该CPU对一个不存在其cache的数据项执行原子的read-modify-write操作。它发送"read invalidate" message，通过"read response" message获取到对应的cache line，该CPU在收到所有"invalidate acknowledge" message后可以完成其状态转换。

转换(e): CPU对一个存在于其cache的原先状态为只读的数据执行一个原子的read-modify-write操作。该CPU必须发送"invalidate" message，并且必须在完成转换前接收到所有的"invalidate acknowledge" message。
 
转换(f): 其他CPU读取cache line，而该cache line由此CPU提供并保留一个只读副本。这个转换由接收到"read" message开始，并且CPU回复一个"read response" message，其中包含请求的数据。

转换(g): 其他CPU想要读取该cache line中的数据，数据可以从内存或该cache line提供，无论哪种情况，该CPU保留对该cache line的只读副本。该转换由接收到"read" message开始，该CPU则发送"read response" message进行回复。

转换(h): CPU意识到它将要写入cache line中的某些数据，于是它发送"invalidate" message。该CPU直到接收到所有"invalidate acknowledge" message才能进行状态转换。

转换(i): 其他CPU对只存在该CPU cache的cache line中的数据执行原子read-modify-write操作，因此该CPU需要invalidtate掉该cache line。该转换由接收到"read invalidate" message开始，并且该CPU返回"read response" message和"invalidate acknowledge" message。

转换(j): CPU向cache line中的数据项写入数据，但该cache line不存在其cache中，于是CPU发送一个"read invalidate" message，期望独占该cache line。CPU直到接收到"read response" message和一系列"invalidate acknowledge"之前才可以完成状态转换（此时只是I->E）。此时可以进行写入数据了，一旦写入完成，cache line将会通过转换(b)进入"modified"状态（E->M）。

转换(k): CPU读取cache line中的数据，但该cache line不存在其cache中，于是CPU发送一个"read" message，期望获取该cache line。并且在接收到"read response"时完成该状态的转换。

转换(l): 其他CPU需要写入在该cache line中的数据，但其只保有只读的状态时会发生该转换。该转换由接收到"invalidate" message开始，并且该CPU发送"invalidate acknowledeg" message进行回复。



## 同步工具

同步工具根据粒度可以分为以下：
- 锁
- 原子操作
- 内存屏障

### 锁、条件变量、信号量

锁是最简单的同步工具，它由操作系统提供，给用户提供互斥的需求，而无需关心底层具体架构。

根据锁无法获得时，采取的不同策略可以分为各种各样的锁：
- 互斥锁（睡眠锁）。
- 自旋锁。
- 读写锁。
- 条件锁（条件变量）。



### 原子操作


### 内存屏障

参考链接：
1. [内存模型与c++中的memroy order](https://www.cnblogs.com/ishen/p/13200838.html)
2. 
