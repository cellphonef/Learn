# C++服务器开发

## C++语言

### C++11/14/17新特性

### 惯用法

**1. RAII**

RAII是C++语言的一个十分重要的惯用法，它是"Resource Acquisition Is Initialization"的首字母简称，中文译为“资源获取即初始化”。意思是我们在获取资源时（例如，new一个对象时）将该资源作为其他对象的初始值进行初始化。

所谓资源就是一旦用了它，用完必须归还给系统，否则将导致系统资源耗尽，各种不好的事情都会发生。我们最常使用的资源就是动态内存，但其实内存只是你必须管理的众多资源之一。其他常见的资源还包括：文件描述符、互斥量、socket等。

尝试在任何情况下都确保资源释放是十分困难的，因为程序的执行流会因为异常而改变，亦或者会存在多条返回路径我们不能保证执行顺序。即便我们谨慎的编写程序确保其没有资源泄露，但一旦我们的程序开始接受维护就有可能导致新的执行路径的产生以及原本不抛异常的函数现在抛异常了。

为了使我们脱离苦海，C++使用RAII来解决资源泄露问题。RAII是一项简单又重要的技术——它利用C++对象生命期的概念来控制程序的资源（例如内存、文件句柄、网络连接等）。RAII技术就是将资源的生命期和对象的生命期绑定，这样就可以利用C++复杂老练的对象管理设施来管理资源。

RAII的两个关键思想是：
1. 获得资源后立刻放进管理对象（将资源和对象生命期绑定）。
2. 管理对象利用析构函数确保资源被释放（对象生命期结束时释放资源）。

:warning: 对于第1点我们应该以独立语句将newed对象置入管理对象（如智能指针）否则可能会造成内存泄露。


RAII简单的实现形式就是创建一个对象：其在构造函数中获取资源，而在析构函数中释放资源（智能指针就是RAII明显的实例）。

```c++
class Resource { /* ... */ }
class ResourceHandle {
public:
    explicit ResourceHandle(Resource* myResource)
        : myResource_(myResource) {}  // 获取资源
    ~ResourceHandle()
        { delete myresource_; }
    Resource* get()
        { return myResource_; }

private:
    Resouce* myResource_;
}

```

每一个RAII class的设计者都必须选择RAII对象的拷贝语义（拷贝构造和拷贝赋值），大多数时候你会选择以下两种可能：
- 禁止拷贝。
- 使用引用计数进行拷贝。


我们将资源放在RAII对象中，可以保证资源不会泄露，但是我们也应该提供对原始资源的访问（提供get方法），因为大部分API可能会直接操作原始资源。








作用：简化资源管理，避免资源泄露，同时提供对原始资源的访问，安全与便利性的统一。




**2. Pimpl**

Pimpl也是一个C++常用的惯用法，它是"Pointer to implement"的首字母简写，中文译为“指向实现的指针”。意思是通过指针指向实现。



作用：避免编译依赖，加速编译



## 工具链


### 服务器管理相关

**SSH——Xshell**



**FTP**

### 编译链接调试相关

**gcc**


**gdb调试**




gdb常用调试命令：
|命令名词|命令缩写|命令说明|
|-------|------|-------|
|run    |r     |运行程序|
|list   |l     |显示程序源代码|
|continue|c    |让暂停的程序继续运行|
|next   |n     |运行到下一行|
|print  | p    |打印变量或寄存器值|
|backtrace|  bt|查看当前线程的调用堆栈|
|frame  |f     |切换到当前调用线程的指定堆栈，通过堆栈序号指定|
|break  |b     |添加断点|
|tbreak |tb    |添加临时断点|
|delete |del   |删除断点|
|enable |enable|启用某个断点|
|disable|disable|禁用某个断点|  
|info   |info   |查看断点/线程等信息|
|watch  |watch |监视某个变量或内存地址的值是否发生变化|
|set args|     |设置程序启动命令行参数 |
|show args |    |查看设置的命令行参数|



## 多线程编程




## 网络编程

### Socket编程

必须掌握的常用的socket API，如下表：
|函数名词|函数简单描述|参数说明|返回值说明|附加说明|
|-------|----------|------|--------|-------|
|socket()| 创建某种类型的socket |参数需要指定协议族和地址族|返回一个监听socket文件描述符||
|bind()| 将socket绑定到（ip，端口号）二元组上|参数指定待绑定socket以及待绑定的ip地址和端口号|成功返回0，失败返回-1||
|listen()|使socket进入listen状态|参数指定待监听的socket以及连接请求等待队列长度|成功返回0，失败返回-1|
|accept()|服务器端尝试接受一个连接||成功时返回创建的socket文件描述符，失败返回-1|由于服务端socket是用于监听的，不能用于与用户进行数据传输的（想一想，如果服务端socket用来传输数据，谁来监听客户端的连接请求？），所以该函数会创建一个新的socket与用户进行数据传输。|
|connect()|客户端向服务端发起连接|参数指定要连接的目的地址信息|成功返回0，失败返回-1|谁调用connect谁就是客户端。|
|send()|通过socket发送数据|参数指定||
|recv()|通过socket接受数据|||
|select()|监听一组socket上的读写和异常事件|||
|gethostbyname()|通过域名获取机器地址|||
|close()|关闭一个socket，回收资源|||
|shutdown()|半关闭socket的收或发通道|||
|setsockopt()|设置socket选项|||
|getsockopt()|获取socket选项|||

> 不要单纯地记忆这些函数的参数，而是掌握每一个函数的细节和重难点。


