# C++服务器开发

## C++语言


### C++基础

**野指针 vs 悬空指针**

A wild pointer is a pointer that has non been correctly initialized and therefore points to some random piece of memory. It is a serious error to have wild pointers.

A dangling pointer is a pointer that used to point to a valid address but now no longer does. There is nothing wrong with having a dangling pointer unless you try to access the memory location pointed at by that pointer. It is always best practise not to have or leave dangling pointers. 


### C++11已弃用特性

弃用（deprecate）并非彻底不能用，只是暗示程序员这些特性将来会从标准中移除，应该尽量避免使用。但是已弃用的特性仍然是标准库的一部分，并且出于兼容性的考虑大部分特性其实会永久保留。

- auto_ptr被弃用，应该使用unique_ptr。
- bool类型的++操作已被弃用。
- 如果一个类有析构函数，仍为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用。
- C语言风格的类型转换被弃用，应该使用新式的类型转换。
- ...



### C++11/14/17/...新特性

#### 自动类型推导

C++98只有一种类型推导机制：
- 函数模板类型推导。

C++11加入了两种新的类型推导机制，因此一共有三种类型推导机制：
- 函数模板类型推导。
- auto类型推导。
- decltype类型推导。

C++14则增加了auto和decltype的使用场景。




#### 左值引用、右值引用、移动语义、完美转发



**std::move和std::forward**

std::move是无条件的将目标转换成右值，而std::forward则是有条件对目标左右值进行转换（如果）。




#### 可调用对象（callable object）

C++11的可调用对象是指：
- 普通函数。
- 函数指针或引用。
- 函数对象：重载了operator()的类对象。
- lambda函数。





**lambda函数的实现原理**

lambda函数的实现实际上是通过重载函数调用符（"operator()"）类对象实现的。当我们定义一个lambda函数时，编译器会为我们生成一个匿名的类，这个类重载了函数调用符，并且将捕获的变量（值捕获或者引用捕获）作为自己的成员变量。



**std::function和std::bind**

`std::function`是一个类模板，它代表通用的可调用对象（将具体可调用对象如函数指针、函数对象、亦或者是lambda函数封装）。

我们在使用`std::function`时需要指定函数的签名，此时`std::function`就代表了所指定函数签名的一切可调用对象，因此它可以接受与所指定函数签名的一切可调用对象。

但是只有`std::function`是不够的，因为它只能接受与指定签名相同的可调动对象，但不能接受任何签名的可调用对象。

不同函数的签名，区别在于：
1. 参数的类型
2. 参数的数量

`std::bind`是一个函数模板，功能就像是函数适配器，它接收一个可调用对象并生成一个新的可调用对象，新的可调用对象"适配了"原来可调用对象的参数列表。






> 返回值类型是不作为函数重载的考虑因素的。



#### 智能指针

C++11引入智能指针来防止资源泄露。

C++11有三种智能指针：
- unique_ptr
- shared_ptr
- weak_ptr



**Tip：优先使用make_shared或make_unique来创建智能指针**

使用make_shared或者make_unique有两方面的好处：
- 效率更高
- 异常安全

我们创建一个智能指针时，有两种方式：

```C++
// 方式一
Widge* p = new Widgt;     // 1. 进行第一次动态分配
shared_ptr<Widge> sp(p);  // 2. 进行第二次动态分配（分配控制块）

```

方式一需要先new，后构造，如果在new和构造之间存在可能出现异常的行为，则可能造成资源泄露。而是用make_shared或者make_unique将一气呵成。



参考：[std::make_shared](https://blog.csdn.net/zhgeliang/article/details/81237053)





#### 异步编程








### 惯用法

**1. RAII**

RAII是C++语言的一个十分重要的惯用法，它是"Resource Acquisition Is Initialization"的首字母简称，中文译为“资源获取即初始化”。意思是我们在获取资源时（例如，new一个对象时）将该资源作为其他对象的初始值进行初始化。

所谓资源就是一旦用了它，用完必须归还给系统，否则将导致系统资源耗尽，各种不好的事情都会发生。我们最常使用的资源就是动态内存，但其实内存只是你必须管理的众多资源之一。其他常见的资源还包括：文件描述符、互斥量、socket等。

尝试在任何情况下都确保资源释放是十分困难的，因为程序的执行流会因为异常而改变，亦或者会存在多条返回路径我们不能保证执行顺序。即便我们谨慎的编写程序确保其没有资源泄露，但一旦我们的程序开始接受维护就有可能导致新的执行路径的产生以及原本不抛异常的函数现在抛异常了。

为了使我们脱离苦海，C++使用RAII来解决资源泄露问题。RAII是一项简单又重要的技术——它利用C++对象生命期的概念来控制程序的资源（例如内存、文件句柄、网络连接等）。RAII技术就是将资源的生命期和对象的生命期绑定，这样就可以利用C++复杂老练的对象管理设施来管理资源。

RAII的两个关键思想是：
1. 获得资源后立刻放进管理对象（将资源和对象生命期绑定）。
2. 管理对象利用析构函数确保资源被释放（对象生命期结束时释放资源）。

:warning: 对于第1点我们应该以独立语句将newed对象置入管理对象（如智能指针）否则可能会造成内存泄露。


RAII简单的实现形式就是创建一个对象：其在构造函数中获取资源，而在析构函数中释放资源（智能指针就是RAII明显的实例）。

```c++
class Resource { /* ... */ }
class ResourceHandle {
public:
    explicit ResourceHandle(Resource* myResource)
        : myResource_(myResource) {}  // 获取资源
    ~ResourceHandle()
        { delete myresource_; }
    Resource* get()
        { return myResource_; }

private:
    Resouce* myResource_;
}

```

每一个RAII class的设计者都必须选择RAII对象的拷贝语义（拷贝构造和拷贝赋值），大多数时候你会选择以下两种可能：
- 禁止拷贝。
- 使用引用计数进行拷贝。


我们将资源放在RAII对象中，可以保证资源不会泄露，但是我们也应该提供对原始资源的访问（提供get方法），因为大部分API可能会直接操作原始资源。








作用：简化资源管理，避免资源泄露，同时提供对原始资源的访问，安全与便利性的统一。




**2. Pimpl**

Pimpl也是一个C++常用的惯用法，它是"Pointer to implement"的首字母简写，中文译为“指向实现的指针”。意思是通过指针指向实现。



作用：避免编译依赖，加速编译



## 工具链


### 服务器管理相关

**SSH——Xshell**



**FTP**

### 编译链接调试相关

**gcc**

gcc指令常用参数：
- -c
- -E
- -s
- -Wall
- -g
- -o


**gdb调试**




gdb常用调试命令：
|命令名词|命令缩写|命令说明|
|-------|------|-------|
|run    |r     |运行程序|
|list   |l     |显示程序源代码|
|continue|c    |让暂停的程序继续运行|
|next   |n     |运行到下一行|
|print  | p    |打印变量或寄存器值|
|backtrace|  bt|查看当前线程的调用堆栈|
|frame  |f     |切换到当前调用线程的指定堆栈，通过堆栈序号指定|
|break  |b     |添加断点|
|tbreak |tb    |添加临时断点|
|delete |del   |删除断点|
|enable |enable|启用某个断点|
|disable|disable|禁用某个断点|  
|info   |info   |查看断点/线程等信息|
|watch  |watch |监视某个变量或内存地址的值是否发生变化|
|set args|     |设置程序启动命令行参数 |
|show args |    |查看设置的命令行参数|



## 多线程编程

> 程序的执行不过就是一堆指令在操作着一堆数据。

多个线程共享的是数据，因此我们应该控制的是多线程对数据的访问，否则将造成数据错乱。

- 「临界区」——访问和操作共享数据的代码段。


as-if-serial semantics: 编译器和处理器为了提高指令执行的效率可能对执行进行重排序，而不管编译器和处理器如何对指令执行进行重排序都不能改变单线程执行程序的执行结果，即好像（as-if）程序仍然是串行执行的（serial）。

编译器和处理器为了压榨性能，虽然提供了as-if-serial semantics的保证，但是同样也引出了一个事实：**程序顺序不等于执行顺序。** 而这对于多线程程序而言，可能造成错误，原因在于线程之间可能会互相依赖于程序顺序，如果执行顺序与程序顺序不同则会导致依赖于该程序顺序的线程出错。

e.g.








  

### 原子操作

> 原子操作是其他同步方法的基石。

原子操作可以保证指令以原子的方式执行——执行过程不被打断。

原子整数操作最常见的用途就是实现计数器。


**原子性和顺序性的比较**

- 原子性确保的是指令在执行期间不被打断，要么全部执行完，要么根本不执行。
- 而顺序性确保即使两条或多条指令出现在独立的执行线程中，甚至独立的处理器上，它们本该的执行顺序依然保持与程序顺序一致。
- 原子操作只保证原子性并不能保证顺序性，顺序性通过屏障来保证。


### 锁

锁有多种多样的形式，而且加锁的粒度范围也各不相同——Linux自身实现了几种不同的锁机制。各种锁机制之间的区别主要在于：当锁已经被其他线程持有，因而不可用时的行为表现。

主要有两种行为表现：
- 自旋等待。
- 睡眠。



**自旋锁**



**锁的实现原理**



**死锁问题**

死锁的产生需要一定的条件：
- 互斥条件。
- 请求和保持条件。如果线程发现需要占有的锁不可用时，则把之前占有的锁释放，则不会发生死锁（？？？）。
- 不可剥夺条件。
- 环路等待条件。


最简单的死锁例子就是「自死锁」：如果一个执行线程试图去获得一个自己已经拥有的锁，它将不得不等待锁被释放，但因为它正在忙着等待这个锁，所以自己永远也不会有机会释放锁，最终结果就是死锁。


同样道理，考虑有n个线程n把锁，如果每个线程都持有一把其他线程需要的锁，那么所有线程都将阻塞等待他们希望得到的锁重新可用，但是绝对没有一个线程会释放自己的锁，于是导致死锁。最常见的例子是有两个线程两把锁的死锁称为「ABBA死锁」。

预防死锁：
- 按顺序加锁，按逆序释放锁。

### 条件变量

条件变量的使用有几个注意点:
- 唤醒丢失：线程唤醒
- 虚假唤醒：线程被唤醒，但是此时条件还没满足或者已经被消费了。

为了防止唤醒丢失，我们需要：
- 添加一个判断条件。
- 调用wait时必须加锁。

为了防止虚假唤醒，我们需要：
- 使用while而不是if来替代判断状态。
- 调用signal时，加锁。


正确用法：

```C++
// 初始化
vector<int> vec;
pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// 消费者
pthread_mutex_lock(&mtx);              // c1
while (vec.empty()) {                  // c2
    pthread_cond_wait(&cond, &mtx);    // c3
}
consume_data(vec);                        
pthread_mutex_unlock(&mtx);            // c4

// 生产者
pthread_mutex_lock(&mtx);              // p1
produce_data(vec);                     // p2
pthread_mutex_unlock(&mtx);            // p3
pthread_cond_signal(&cond);            // p4 
```


### 应用——线程池

线程本质就是一个函数的执行，只是主线程的入口函数是main，而其他线程的入口函数就是需要执行的函数。

当该执行函数执行完后线程也就结束了，那么如何复用线程呢？为了复用线程我们需要让线程不断的循环执行调度函数，然后从任务队列中取出任务，如果没有任务则阻塞等待，当线程池不再使用后再停止循环。

因此线程池（ThreadPool）的组件包括以下内容：
- 任务队列存放要执行的函数（TaskQueue）。
- 工作线程（worker）。
- 



## 网络编程

### Socket编程

必须掌握的常用的socket API，如下表：
|函数名词|函数简单描述|参数说明|返回值说明|附加说明|
|-------|----------|------|--------|-------|
|socket()| 创建某种类型的socket |参数需要指定协议族和地址族|返回一个监听socket文件描述符||
|bind()| 将socket绑定到（ip，端口号）二元组上|参数指定待绑定socket以及待绑定的ip地址和端口号|成功返回0，失败返回-1||
|listen()|使socket进入listen状态|参数指定待监听的socket以及连接请求等待队列长度|成功返回0，失败返回-1|
|accept()|服务器端尝试接受一个连接||成功时返回创建的socket文件描述符，失败返回-1|由于服务端socket是用于监听的，不能用于与用户进行数据传输的（想一想，如果服务端socket用来传输数据，谁来监听客户端的连接请求？），所以该函数会创建一个新的socket与用户进行数据传输。|
|connect()|客户端向服务端发起连接|参数指定要连接的目的地址信息|成功返回0，失败返回-1|谁调用connect谁就是客户端。|
|send()|通过socket发送数据|参数指定||
|recv()|通过socket接受数据|||
|select()|监听一组socket上的读写和异常事件|||
|gethostbyname()|通过域名获取机器地址|||
|close()|关闭一个socket，回收资源|||
|shutdown()|半关闭socket的收或发通道|||
|setsockopt()|设置socket选项|||
|getsockopt()|获取socket选项|||

> 不要单纯地记忆这些函数的参数，而是掌握每一个函数的细节和重难点。



## 高性能服务器开发




### Reactor & Proactor

四个基本概念：
- 阻塞IO：用户执行read，线程会被阻塞，一直等到内核把数据准备好，并把数据从内核缓冲区拷贝到应用程序缓冲区中，当拷贝过程完成，read才会返回。
- 非阻塞IO：非阻塞的read请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序区，read调用才可以获取到结果（注意，当read调用发现数据已经准备好后则需要等待内核将数据拷贝到用户程序区，这个过程是需要等待的）。
- 同步IO：其中阻塞IO和非阻塞IO都可以看做是同步IO，因为在调用时，都要等待内核把数据从内核空间拷贝到用户空间中。
- 异步IO：当我们发起异步的read操作后就立即返回，当数据准备好时内核自动将数据从内核空间拷贝到用户空间，然后通知用户程序。



有了以上基本概念，我们再来理解Reactor和Proactor模式：
- Reactor是非阻塞同步网络模式，感知的是事件就绪可读写事件。**在每次感知到有事件发生时，就需要应用程序主动调用read来完成数据的读取**，也就是要应用程序主动将socket接收缓存区中的数据读到应用进程内存中，该过程是同步的，读取完数据后应用程序才能处理数据。
- Proactor是异步网络模式，感知的是已完成的读写事件。在发起异步读写请求时，需要传入数据缓存区的地址等各种信息以便内核能够有足够的信息来帮我们代劳，**内核完成读写工作后，就会通过回调通知应用程序直接处理数据。**

无论是Reactor，还是Proactor都是一种基于事件分发的网络编程模式，区别在于Reactor模式是基于就绪的IO事件，而Proactor模式是基于已完成IO事件。




