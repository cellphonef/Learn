# CPP

最初，C++只是C语言加上一些面向对象的特性，所以C++的原名是"C with Classes"。

现在的C++已经逐渐成熟，成为一门**多范式的程序设计语言（multiparadigm programming language）**。同时支持：
- 过程形式（procedural）
- 面向对象形式（object-oriented）
- 函数形式（functional）
- 泛型形式（generic）
- 元编程形式（metaprogramming）

这些能力和弹性使得C++成为一个无可匹敌的语言，但是各个范式之间并没有紧密的关联性。

最好将C++看成一个由相关语言组成的联邦而非单一的语言。在其某个次语言（sublanguage）中，各种守则与通例都倾向简单、直观易懂、并且容易记住。然而当你从一个次语言移往另一个次语言，守则可能改变。

C++主要得次语言总共四个：
- C
- Object-Oriented C++
- Template C++
- STL


## C 核心

C最核心的就是指针。





## Object-Oriented C++ 核心

面向对象主要分为4个部分：
- 数据抽象
- 封装
- 继承
- 多态



## Template C++ 核心

Template C++即泛型编程，其关注点是如何让同一套代码适用于不同的类型。

Template C++的核心即为template，主要有两种：
- function template
- class template

function template又分为
- non-member function（即normal function），对应normal function tempalte。
- member function，对应member function template。


### 核心一：类型推导

由于对于class template不存在类型推导（需要直接指定），因此类型推导主要存在以下三种场景：
- 函数模板参数类型推导
- auto类型推导
- delctype类型推导

**1. 函数模板参数类型推导**

**对于函数模版参数类型推导，编译器利用函数实参来推导其模版参数类型。**

对于函数模板的定义，函数模板参数就是一个类型，因此我们可以像非模板函数一样利用该模板参数对函数模板进行定义。C++11以前一共有以下三种情况：

```c++
// 1. 
template <typename T>
void func1(T arg);

// 2.
template <typename T>
void func2(T* arg);

// 3.
template <typename T>
void func3(T& arg);

int i = 5;
const int ci = i;

int* pi = &i;
const int* pci = &ci;
const int* const cpci = &ci;

int& ri = i;
const int& rci = ci;
// 由于引用初始化后不可改变因此不存在const int& const crci

func1(i);       // T = int
func1(ci);      // T = int, 值传递顶层const被忽略
func1(pi);      // T = int*, 声明式中不包含*则推导后有*
func1(pci);     // T = const int*, 值传递底层const保留，声明式中不包含*则推导后有*
func1(cpci);    // T = const int*, 值传递底层const保留，顶层const被忽略，声明式中不包含*则推导后有*
func1(ri);      // T = int, 引用被忽略
func1(rci);     // T = int, 引用被忽略，顶层const被忽略



```













当一个左值引用含有const时（即`const T&`），我们可以传递给它左值和右值（因此可以接受任何类型的值）。当函数参数本身是const时，T的类型推导将不会再含有const（参数已经包含了没必要再包含了）。

```C++
template <typename T>
void fun(const T& arg);

fun(i);    // T is int
fun(ci);   // T is int
fun(5);    // T is int
```


当一个函数参数是模板类型参数的右值引用时，正常的绑定规则告诉我们可以传递右值。当我们这样做时，类型推导过程类似普通左值引用函数参数的推导过程，即推导出的类型为该右值实参的类型。

```C++
template <typename T>
void fun(T&& arg);

fun(5);    // T is int
fun(6.0);  // T is double
 ```

 从正常绑定规则来讲，不可以传递左值，但实际上C++在正常绑定规则之外定义了两个例外规则：
 1. 当我们将一个左值传递给函数的右值引用参数，且此右值引用参数指向模板类型参数时，编译器推导模板类型参数为实参的左值引用类型。
 2. 如果我们间接创建一个引用的引用，则这些引用形成了"折叠"，编译器会进行引用折叠处理。



在实际中，函数模板的依赖于模板类型参数的右值引用参数通常用于两种情况：
- 完美转发。
- 模板重载。

首先对于完美转发，我们要的是将实参的类型完完整整的传递给其他函数，因此：
- 对于传递进来的左值，我们应该保持它左值的性质以及它的const属性（因此需要传引用）。
- 对于传递进来的右值，保持它右值的性质以及const属性。


而对于模板重载，我们知道实际上左值和右值是有区别的，我们要利用他们的区别来提高程序的效率。因此，我们在模板重载时会区分开左值和右值。




> 当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。












完美转发

某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质，包括实参类型是否为const以及实参是左值还是右值。


与往常一样，顶层const无论是在形参还是实参中，都会被忽略（更高的灵活性）。在其他类型转换中，能在调用中应用于函数模版的包括如下两项：
- const转换：可以将一个非const对象的引用（或指针）传递给一个const的引用（或指针）形参。
- 数组或函数指针转换：如果函数形参不是引用类型（引用是别名，类型必须和实参一致），则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的一个函数实参可以转换为一个该函数类型的指针（其他转换都不能应用于函数模板，相反编译器生成新的模板实例）。

如果一个函数形参的类型使用了模版类型参数，那么它将采用特殊的初始化规则。只有很有限的几种类型转换会自动地应用于这些实际参数。因为编译器通常不是对实参进行类型转换，而是生成一个新的模版实例。



**2. auto类型推导**

auto类型推导使用初始化值来进行类型推导。

**3. decltype类型推导**

decltype类型推导使用表达式来进行类型推导（不过不会执行对应的表达式）。










## STL 核心

STL是一个template程序库，它是一套完整的程序库。它包含六个组件：
- 容器（container）
- 迭代器（iterator）
- 算法（ algorithm）
- 适配器（adpator）
- 函数对象（function objects）





## 构建大型项目


### 异常安全

基础

**栈展开**

栈展开过程中位于调用链上的语句块可能会提前退出。通常情况下，程序在这些块中创建了一些局部对象。「块退出后它的局部对象也将随之销毁」，这条规定对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象被正确地销毁。如果某个局部对象是类类型，则该对象的析构函数将被自动调用，而对于内置类型时不需要做任何事情。

部分构造：
- 如果异常发生在构造函数中，则当前对象可能只构造了一部分。有的成员已经初始化，而另一些成员在异常发生前还没初始化，在这种情况下，即使某个对象只构造了一部分，C++也确保「已构造」的成员能被正确地销毁。
- 如果异常发生在数组或标准库容器的元素初始化过程中，如果在异常发生前已经构造了一部分元素，则C++也确保「已构造」的元素被正确地销毁。

出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块当中，并且在析构函数内部得到处理。


RAII

析构函数总是会被执行（非异常情况/异常情况），但是函数中负责释放资源的代码却可能被跳过，这一特点即RAII的核心。如果我们使用类来控制资源的分配，就能确保无论函数是否正常结束还是遭遇异常，资源都能被正确地释放。


### 命名空间

命名空间为防止名字冲突提供了更加可控的机制。「命名空间分割了全局命名空间，其中每个命名空间是一个作用域。」

命名空间可以是不连续的。

全局命名空间

嵌套的命名空间


内联命名空间

未命名的命名空间

using声明（using declaration）& using指示（using directive）

```cpp 
using std::string;     // using declaration
using namespace std;   // using directive
```

一条using声明的作用相当于在「当前作用域」引入一个名字。如果外层作用域有相同的名字则会被隐藏。

一条using指示一次性将其命名空间的所有成员注入「包含当前作用域和命名空间所在作用域的作用域——最近共同祖先（而不是当前作用域）。」

在一个作用域的有向无环图DAG中，两个节点的最近共同祖先可以通过跟踪从两个节点开始到根节点的路径，两个节点第一次相交时就是它们的最近共同祖先。

在命名空间中使用using指令是具有传递性的。

注意：using的作用只能用的unqualified name lookup！！直接使用作用域限定符来访问注入的使用using注入的成员将报错，因为对于这些qualified name lookup不会考虑using。






重载与using声明






